import { Observable } from 'rxjs';

interface JwtUser {
    client_id: string;
    exp: number;
    ext: {
        first_name: string;
        type: string;
    };
    iat: number;
    iss: string;
    jti: string;
    sub: string;
    nbf: number;
    scp: string[];
}
declare class JwtHelper {
    token: string;
    constructor(token: string);
    urlBase64Decode(str: string): string;
    private b64decode;
    private b64DecodeUnicode;
    decodeToken(token?: string): any;
    getJWTUser(token?: string): JwtUser | null;
    getTokenExpirationDate(token?: string): Date | null;
    isTokenExpired(token?: string, offsetSeconds?: number): boolean;
}

type AccountTypes = 'stash-trial' | 'v3starter' | 'v3fly' | 'v3growth' | 'v3enterprise' | 'stash-basic' | 'stash-team' | 'stash-startup' | 'stash-starter' | 'stash-growth' | 'stash-enterprise' | 'stash-developer' | 'stash-business';
declare const NUA_KEY = "NUCLIA_NUA_KEY";
interface Account {
    blocked_features: BlockedFeature[];
    blocking_state?: AccountBlockingState;
    can_manage_account: boolean;
    config?: AccountConfig;
    current_kbs?: number;
    current_users?: number;
    domain?: string;
    description?: string;
    id: string;
    limits?: AccountLimits;
    max_kbs: number;
    max_users: number | null;
    saml_entity_id?: string;
    saml_sso_url?: string;
    saml_x509_cert?: string;
    slug: string;
    title: string;
    trial_expiration_date?: string;
    type: AccountTypes;
    zone: string;
}
interface AccountConfig {
    g_speech_to_text: boolean;
    indexer_slow_replicas: number;
    max_dedicated_processors: number;
}
type UploadLimitsEntries = 'upload_limit_max_media_file_size' | 'upload_limit_max_non_media_file_size';
type UploadLimits = Record<UploadLimitsEntries, number>;
type NullableUploadLimits = Record<UploadLimitsEntries, number | null>;
type UsageLimitsEntries = 'monthly_limit_docs_no_media_processed' | 'monthly_limit_hosted_answers_generated' | 'monthly_limit_hosted_searches_performed' | 'monthly_limit_media_seconds_processed' | 'monthly_limit_paragraphs_processed' | 'monthly_limit_paragraphs_stored' | 'monthly_limit_self_hosted_answers_generated' | 'monthly_limit_self_hosted_searches_performed';
type UsageLimits = Record<UsageLimitsEntries, number>;
type NullableUsageLimits = Record<UsageLimitsEntries, number | null>;
interface AccountLimits {
    upload: UploadLimits;
    usage: UsageLimits;
}
interface AccountLimitsPatchPayload {
    upload: NullableUploadLimits;
    usage: NullableUsageLimits;
}
declare enum AccountBlockingState {
    UNBLOCKED = "unblocked",
    QUOTA = "quota",
    MANAGER = "manager"
}
declare enum BlockedFeature {
    UPLOAD = "upload",
    PROCESSING = "processing",
    SEARCH = "search",
    GENERATIVE = "generative",
    TRAINING = "training",
    PUBLIC_UPLOAD = "public_upload",
    PUBLIC_PROCESSING = "public_processing",
    PUBLIC_SEARCH = "public_search",
    PUBLIC_GENERATIVE = "public_generative"
}
interface AccountCreation {
    slug: string;
    title: string;
    description?: string;
    email?: string;
    zone?: string;
}
interface AccountModification {
    title?: string;
    description?: string;
    g_speech_to_text?: boolean;
    saml?: {
        domain: string;
        entity_id: string;
        sso_url: string;
        x509_cert: string;
    };
}
interface AccountStatus {
    available: boolean;
}
declare enum StatsPeriod {
    DAY = "day",
    WEEK = "week",
    MONTH = "month",
    YEAR = "year"
}
declare enum StatsRange {
    anHour = "1h",
    twoHours = "2h",
    threeHours = "3h",
    sixHours = "6h",
    twelveHours = "12h",
    twentyFourHours = "24h",
    fortyHeightHours = "48h"
}
interface ProcessingStat {
    time_period: string;
    stats: number;
}
declare enum StatsType {
    PROCESSING_TIME = "processing_time",
    SEARCHES = "searches",
    CHARS = "chars",
    MEDIA_SECONDS = "media_seconds",
    BYTES = "bytes",
    RESOURCES = "resources",
    PAGES = "pages",
    TRAIN_SECONDS = "train_seconds",
    SUGGESTIONS = "suggestions",
    DOCS_NO_MEDIA = "docs_no_media",
    AI_TOKENS_USED = "ai_tokens_used"
}
interface Welcome {
    preferences: WelcomeUser;
    accounts: string[];
    create: boolean;
    dependant_accounts: {
        id: string;
        slug: string;
    }[];
}
interface WelcomeUser {
    last_login?: string;
    email: string;
    name?: string;
    type: UserType;
    language?: Language;
}
type UserType = 'ROOT' | 'DEALER' | 'USER';
type Language = 'CA' | 'ES' | 'EN';
interface NUAClientPayload {
    allow_kb_management?: boolean;
    client_id?: string;
    contact: string;
    description?: string;
    title: string;
    webhook?: string;
}
interface NUAClient extends NUAClientPayload {
    client_id: string;
    created: string;
    partitions: 0;
    zone: string;
}
interface ProcessingPushResponse {
    seqid: number;
    account_seq: number;
    uuid: string;
}
interface ProcessingPullResponse {
    status: string;
    payload?: string;
    msgid?: string;
}
interface LearningConfigurations {
    [key: string]: LearningConfiguration;
}
interface LearningConfigurationOption {
    value: string;
    name: string;
    user_key?: string;
    user_prompt?: string;
}
interface LearningConfiguration {
    options?: LearningConfigurationOption[];
    schema?: LearningConfigurationSchema;
    schemas?: {
        [key: string]: LearningConfigurationSchema;
    };
    default: string;
    create: boolean;
    update: boolean;
}
declare function normalizeSchemaProperty(config: LearningConfigurations): LearningConfigurations;
declare const USER_PROMPTS = "user_prompts";
declare const SUMMARY_PROMPT = "summary_prompt";
interface LearningConfigurationSchema {
    title: string;
    type: string;
    properties: {
        [key: string]: {
            title: string;
            type: string;
            widget?: string;
            info?: string;
            examples?: string[];
        };
    };
    required: string[];
}
type LearningConfigurationSet = {
    id: string;
    data: LearningConfiguration;
}[];
interface LearningConfigurationUserKeys {
    [key: string]: {
        [key: string]: {
            title: string;
            required: boolean;
            textarea: boolean;
        };
    };
}
interface PredictedToken {
    text: string;
    ner: string;
    start: number;
    end: number;
}
declare enum ResourceProperties {
    BASIC = "basic",
    ORIGIN = "origin",
    RELATIONS = "relations",
    VALUES = "values",
    EXTRACTED = "extracted",
    ERRORS = "errors",
    EXTRA = "extra",
    SECURITY = "security"
}
interface KbIndex {
    account_id: string;
    kb_id: string;
    zone_id: string;
}

interface UploadResponse {
    resource?: string;
    field?: string;
    progress?: number;
    failed?: boolean;
    completed?: boolean;
    conflict?: boolean;
}
interface UploadStatus {
    files: FileUploadStatus[];
    progress: number;
    completed: boolean;
    uploaded: number;
    failed: number;
    conflicts?: number;
}
interface FileUploadStatus {
    file: File;
    progress: number;
    uploaded: boolean;
    failed: boolean;
    conflicts?: boolean;
}
interface FileWithMetadata extends File {
    lang?: string;
    md5?: string;
    payload?: ICreateResource;
}
interface FileMetadata {
    lang?: string;
    contentType?: string;
    filename?: string;
    md5?: string;
    rslug?: string;
}
declare const upload: (nuclia: INuclia, path: string, data: File | FileWithMetadata | ArrayBuffer, TUS: boolean, metadata?: FileMetadata) => Observable<UploadResponse>;
declare const uploadFile: (nuclia: INuclia, path: string, buffer: ArrayBuffer, metadata?: FileMetadata) => Observable<UploadResponse>;
declare const TUSuploadFile: (nuclia: INuclia, path: string, buffer: ArrayBuffer, metadata?: FileMetadata, creationPayload?: ICreateResource) => Observable<UploadResponse>;
declare const batchUpload: (nuclia: INuclia, path: string, files: FileList | File[] | FileWithMetadata[], isResource?: boolean) => Observable<UploadStatus>;
declare const uploadToProcess: (nuclia: INuclia, nuaKey: string, file: File, metadata?: FileMetadata) => Observable<string>;
declare const getFileMetadata: (metadata: FileMetadata | undefined) => {
    [key: string]: string;
};

interface IResource {
    id: string;
    slug?: string;
    title?: string;
    summary?: string;
    icon?: string;
    metadata?: Metadata;
    usermetadata?: UserMetadata;
    fieldmetadata?: UserFieldMetadata[];
    computedmetadata?: ComputedMetadata;
    extra?: ExtraMetadata;
    origin?: Origin;
    security?: Security;
    created?: string;
    modified?: string;
    thumbnail?: string;
    last_seqid?: number;
    last_account_seq?: number;
    queue?: 'private' | 'shared';
    data?: ResourceData;
}
type ResourceData = {
    files?: {
        [key: string]: FileFieldData;
    };
    links?: {
        [key: string]: LinkFieldData;
    };
    texts?: {
        [key: string]: TextFieldData;
    };
    keywordsets?: {
        [key: string]: KeywordSetFieldData;
    };
};
interface ICreateResource {
    title?: string;
    summary?: string;
    slug?: string;
    icon?: string;
    metadata?: Metadata;
    usermetadata?: UserMetadata;
    fieldmetadata?: UserFieldMetadata[];
    origin?: Origin;
    extra?: ExtraMetadata;
    files?: {
        [key: string]: FileField;
    };
    links?: {
        [key: string]: LinkField;
    };
    texts?: {
        [key: string]: TextField;
    };
    keywordsets?: {
        [key: string]: KeywordSetField;
    };
    conversations?: {
        [key: string]: ConversationField;
    };
}
declare enum FIELD_TYPE {
    text = "text",
    file = "file",
    link = "link",
    layout = "layout",
    conversation = "conversation",
    keywordset = "keywordset",
    datetime = "datetime",
    generic = "generic"
}
declare enum RESOURCE_STATUS {
    PENDING = "PENDING",
    PROCESSED = "PROCESSED",
    ERROR = "ERROR",
    DELETED = "DELETED"
}
interface Metadata {
    language?: string;
    languages?: string[];
    status?: RESOURCE_STATUS;
}
interface UserMetadata {
    classifications?: UserClassification[];
    relations?: Relation[];
}
interface ExtraMetadata {
    metadata: object;
}
type RelationType = 'ABOUT' | 'CHILD' | 'COLAB' | 'ENTITY' | 'OTHER' | 'SYNONYM';
type RelationEntityType = 'entity' | 'label' | 'resource' | 'user';
interface Relation {
    relation: RelationType;
    label?: string;
    from?: RelationEntity;
    to: RelationEntity;
}
interface RelationEntity {
    value: string;
    type: RelationEntityType;
    group?: string;
}
interface Origin {
    source_id?: string;
    url?: string;
    created?: string;
    modified?: string;
    metadata?: {
        [key: string]: string;
    };
    tags?: string[];
    collaborators?: string[];
    filename?: string;
    related?: string[];
    source?: 'WEB' | 'DESKTOP' | 'API';
    path?: string;
}
interface Security {
    access_groups: string[];
}
interface IError {
    body: string;
    code: number;
}
interface IFieldData {
    value?: TextField | FileField | LinkField | KeywordSetField | ConversationField;
    extracted?: ExtractedData;
    error?: IError;
}
interface FieldId {
    field_type: FIELD_TYPE;
    field_id: string;
}
interface FieldFullId extends FieldId {
    resourceId: string;
}
interface ResourceField extends IFieldData, FieldId {
}
declare class FileFieldData implements IFieldData {
    value?: FileField;
    extracted?: FileFieldExtractedData;
    error?: IError;
}
interface FileField {
    added?: string;
    file?: CloudLink;
    language?: string;
    password?: string;
    external?: boolean;
}
interface FileFieldExtractedData extends ExtractedData {
    file?: FileExtractedData;
}
interface FileExtractedData {
    language?: string;
    md5?: string;
    metadata?: {
        [id: string]: string;
    };
    nested?: {
        [id: string]: string;
    };
    file_generated?: {
        [id: string]: CloudLink;
    };
    file_rows_previews?: {
        [id: string]: RowsPreview;
    };
    file_preview?: CloudLink;
    file_pages_previews?: FilePages;
    file_thumbnail?: CloudLink;
    field?: string;
    icon?: string;
    nested_position?: {
        [id: string]: NestedPosition;
    };
}
interface NestedPosition {
    start?: number;
    end?: number;
    page?: number;
}
interface Row {
    cell?: string[];
}
interface Sheet {
    rows?: Row[];
}
interface RowsPreview {
    sheets?: {
        [id: string]: Sheet;
    };
}
interface WriteFileField {
    language?: string[];
    file: FileB64;
}
interface PagePositions {
    start?: number;
    end?: number;
}
interface PageStructure {
    page: {
        width: number;
        height: number;
    };
    tokens: PageToken[];
}
interface PageToken {
    x: number;
    y: number;
    width: number;
    height: number;
    text: string;
    line: number;
}
interface FilePages {
    pages?: CloudLink[];
    positions?: PagePositions[];
    structures?: PageStructure[];
}
interface FileB64 {
    filename: string;
    content_type?: string;
    payload: string;
    md5: string;
}
interface LinkField {
    added?: string;
    headers?: {
        [id: string]: string;
    };
    cookies?: {
        [id: string]: string;
    };
    uri?: string;
    language?: string;
    localstorage?: {
        [id: string]: string;
    };
    css_selector?: string | null;
}
declare class TextFieldData implements IFieldData {
    value?: TextField;
    extracted?: ExtractedData;
    error?: IError;
}
type TextFormat = 'PLAIN' | 'MARKDOWN' | 'HTML' | 'RST';
type TextFieldFormat = TextFormat | 'JSON';
interface TextField {
    body: string;
    format?: TextFieldFormat;
}
interface ExtractedData {
    text?: ExtractedText;
    metadata?: FieldComputedMetadata;
}
interface ExtractedText {
    text?: string;
    split_text?: {
        [id: string]: string;
    };
    deleted_splits?: string[];
}
interface FieldComputedMetadata {
    metadata: FieldMetadata;
    split_metadata?: {
        [id: string]: FieldMetadata;
    };
    deleted_splits?: string[];
}
interface FieldMetadata {
    links: string[];
    paragraphs: Paragraph[];
    ner: {
        [id: string]: string;
    };
    classifications: Classification[];
    last_index?: string;
    last_understanding?: string;
    last_extract?: string;
    last_summary?: string;
    thumbnail?: CloudLink;
    language?: string;
    summary?: string;
    positions?: EntityPositions;
    relations?: Relation[];
}
interface EntityPositions {
    [entityId: string]: EntityPosition;
}
interface EntityPosition {
    entity: string;
    position: {
        start: number;
        end: number;
    }[];
}
interface UserFieldMetadata {
    field: {
        field: string;
        field_type: string;
    };
    paragraphs?: ParagraphClassification[];
    token?: UserTokenAnnotation[];
    selections?: PageSelections[];
}
interface PageSelections {
    page: number;
    visual: VisualSelection[];
}
interface VisualSelection {
    label: string;
    top: number;
    left: number;
    right: number;
    bottom: number;
    token_ids: number[];
}
interface TokenAnnotation {
    token: string;
    klass: string;
    start: number;
    end: number;
}
interface UserTokenAnnotation extends TokenAnnotation {
    cancelled_by_user?: boolean;
}
interface ParagraphClassification {
    classifications: Classification[];
    key: string;
}
declare class KeywordSetFieldData implements IFieldData {
    value?: KeywordSetField;
    extracted?: ExtractedData;
    error?: IError;
}
interface KeywordSetField {
    keywords: {
        value: string;
    }[];
}
interface Classification {
    labelset: string;
    label: string;
    immutable?: boolean;
}
interface UserClassification extends Classification {
    cancelled_by_user?: boolean;
}
type TypeParagraph = 'TEXT' | 'OCR' | 'INCEPTION' | 'DESCRIPTION' | 'TRANSCRIPT';
interface Paragraph {
    start?: number;
    end?: number;
    start_seconds?: number[];
    end_seconds?: number[];
    kind?: TypeParagraph;
    classifications?: Classification[];
    sentences?: Sentence[];
    key?: string;
    order?: number;
}
interface Sentence {
    start?: number;
    end?: number;
    key?: string;
}
interface CloudLink {
    filename?: string;
    md5?: string;
    uri?: string;
    size?: number;
    content_type?: string;
    extra_headers?: {
        [key: string]: string;
    };
}
declare class LinkFieldData implements IFieldData {
    value?: LinkField;
    extracted?: LinkFieldExtractedData;
    error?: IError;
}
interface LinkFieldExtractedData extends ExtractedData {
    link?: LinkExtractedData;
}
interface LinkExtractedData {
    date?: string;
    language?: string;
    title?: string;
    metadata?: {
        [id: string]: string;
    };
    link_thumbnail?: CloudLink;
    link_preview?: CloudLink;
    field?: string;
    link_image?: CloudLink;
    description?: string;
    type?: string;
    embed?: string;
}
interface PositionedNER {
    entity: string;
    family: string;
    start: number;
    end: number;
}
interface ComputedMetadata {
    field_classifications: FieldClassification[];
}
interface FieldClassification {
    field: FieldId;
    classifications: Classification[];
}
declare class ConversationFieldData implements IFieldData {
    value?: ConversationField;
    extracted?: ExtractedData;
    error?: IError;
}
interface ConversationField {
    messages: Message[];
}
interface Message {
    ident: string;
    content: MessageContent;
    timestamp?: string;
    who?: string;
    to?: string[];
    type?: 'QUESTION' | 'ANSWER';
}
interface MessageContent {
    text: string;
    format?: TextFormat;
    attachments?: MessageAttachment[];
}
interface MessageAttachment {
    filename: string;
    content_type?: string;
    payload: string;
    md5: string;
}
declare enum ResourceFieldProperties {
    VALUE = "value",
    EXTRACTED = "extracted",
    ERROR = "error"
}
declare enum ExtractedDataTypes {
    TEXT = "text",
    METADATA = "metadata",
    SHORTENED_METADATA = "shortened_metadata",
    LARGE_METADATA = "large_metadata",
    VECTOR = "vectors",
    LINK = "link",
    FILE = "file"
}

declare const LABEL_FILTER_PREFIX = "classification.labels";
declare const NER_FILTER_PREFIX = "entities";
declare function getFilterFromLabel(label: Classification): string;
declare function getLabelFromFilter(filter: string): Classification;
declare function getFilterFromLabelSet(labelSet: string): string;
declare function getLabelSetFromFilter(filter: string): string;
declare function getFilterFromEntity(entity: {
    family: string;
    entity: string;
}): string;
declare function getEntityFromFilter(filter: string): {
    family: string;
    entity: string;
};

type ResourceStatus = 'PENDING' | 'PROCESSED' | 'ERROR';
type SortOrder = 'asc' | 'desc';
declare enum SortField {
    created = "created",
    modified = "modified",
    title = "title"
}
interface SortOption {
    field: SortField;
    limit?: number;
    order?: SortOrder;
}
declare enum FilterOperator {
    all = "all",
    any = "any",
    none = "none",
    not_all = "not_all"
}
type Filter = {
    [operator in FilterOperator]?: string[];
};
interface BaseSearchOptions {
    fields?: string[];
    filters?: string[] | Filter[];
    min_score?: number;
    range_creation_start?: string;
    range_creation_end?: string;
    range_modification_start?: string;
    range_modification_end?: string;
    show?: ResourceProperties[];
    extracted?: ExtractedDataTypes[];
    field_type_filter?: FIELD_TYPE[];
    resource_filters?: string[];
    shards?: string[];
    autofilter?: boolean;
    highlight?: boolean;
}
interface ChatOptions extends BaseSearchOptions {
    synchronous?: boolean;
    prompt?: string;
    /**
     * It will return the text blocks that have been effectively used to build each section of the answer.
     */
    citations?: boolean;
    rag_strategies?: RAGStrategy[];
    generative_model?: string;
}
interface SearchOptions extends BaseSearchOptions {
    inTitleOnly?: boolean;
    faceted?: string[];
    sort?: SortOption;
    page_number?: number;
    page_size?: number;
    with_status?: ResourceStatus;
    with_duplicates?: boolean;
    with_synonyms?: boolean;
}
declare enum SHORT_FIELD_TYPE {
    layout = "l",
    text = "t",
    file = "f",
    link = "u",
    datetime = "d",
    keywordset = "k",
    generic = "a",
    conversation = "c"
}
declare namespace Search {
    enum Features {
        PARAGRAPH = "paragraph",
        DOCUMENT = "document",
        RELATIONS = "relations",
        VECTOR = "vector"
    }
    enum ResourceFeatures {
        PARAGRAPH = "paragraph",
        RELATIONS = "relations",
        VECTOR = "vector"
    }
    enum SuggestionFeatures {
        PARAGRAPH = "paragraph",
        ENTITIES = "entities",
        INTENT = "intent"
    }
    interface FindResults {
        type: 'findResults';
        resources?: {
            [id: string]: FindResource;
        };
        shards?: string[];
        next_page: boolean;
        page_number: number;
        page_size: number;
        query: string;
        total: number;
        relations?: Relations;
        autofilters?: string[];
        searchId?: string;
    }
    interface FindResource extends IResource {
        fields: {
            [id: string]: FindField;
        };
    }
    interface FindField {
        paragraphs: {
            [id: string]: FindParagraph;
        };
    }
    enum FindScoreType {
        VECTOR = "VECTOR",
        BM25 = "BM25",
        BOTH = "BOTH"
    }
    interface FindParagraph {
        order: number;
        score: number;
        score_type: FindScoreType;
        text: string;
        id: string;
        labels: string[];
        position: {
            index: number;
            start: number;
            end: number;
            start_seconds?: number[];
            end_seconds?: number[];
            page_number?: number;
        };
    }
    interface Results {
        type: 'searchResults';
        resources?: {
            [id: string]: IResource;
        };
        sentences?: Sentences;
        paragraphs?: Paragraphs;
        fulltext?: Fulltext;
        relations?: Relations;
        shards?: string[];
    }
    interface Pagination {
        total: number;
        page_number: number;
        page_size: number;
        next_page: boolean;
    }
    interface FieldResult extends IResource {
        paragraphs?: FindParagraph[];
        field?: FieldId;
        fieldData?: IFieldData;
    }
    interface Suggestions {
        type: 'suggestions';
        paragraphs?: Paragraphs;
        entities?: EntitySuggestions;
    }
    interface EntitySuggestions {
        total?: number;
        entities?: {
            value: string;
            family: string;
        }[];
    }
    interface Sentences extends Pagination {
        results: Sentence[];
        facets: FacetsResult;
    }
    interface Fulltext extends Pagination {
        results: FulltextResource[];
        facets: FacetsResult;
    }
    interface Paragraphs extends Pagination {
        results: Paragraph[];
        facets: FacetsResult;
    }
    interface Relations {
        entities: {
            [key: string]: {
                related_to: Relation[];
            };
        };
    }
    interface Relation {
        entity: string;
        entity_type: RelationEntityType;
        relation: RelationType;
        relation_label: string;
        direction: 'in' | 'out';
    }
    interface FacetsResult {
        [key: string]: {
            [value: string]: number;
        };
    }
    interface Paragraph {
        order: number;
        score: number;
        rid: string;
        field_type: SHORT_FIELD_TYPE;
        field: string;
        text: string;
        labels: string[];
        start_seconds?: number[];
        end_seconds?: number[];
        position?: {
            page_number: number;
            start: number;
            end: number;
            index: number;
        };
    }
    interface Sentence {
        score: number;
        rid: string;
        field_type: SHORT_FIELD_TYPE;
        field: string;
        text: string;
        position?: {
            page_number?: number;
            start: number;
            end: number;
            index: number;
        };
    }
    interface FulltextResource {
        score: number;
        rid: string;
        field_type: string;
        field: string;
    }
}

declare const find: (nuclia: INuclia, kbid: string, path: string, query: string, features?: (Search.Features | Search.ResourceFeatures)[], options?: SearchOptions, useGet?: boolean) => Observable<Search.FindResults | IErrorResponse>;
declare const search: (nuclia: INuclia, kbid: string, path: string, query: string, features?: Search.Features[] | Search.ResourceFeatures[], options?: SearchOptions, useGet?: boolean) => Observable<Search.Results | IErrorResponse>;
declare const catalog: (nuclia: INuclia, kbid: string, query: string, options?: SearchOptions, useGet?: boolean) => Observable<Search.Results | IErrorResponse>;
declare const suggest: (nuclia: INuclia, kbid: string, path: string, query: string, inTitleOnly: boolean, features: Search.SuggestionFeatures[]) => Observable<Search.Suggestions | IErrorResponse>;

declare namespace Chat {
    interface Entry {
        question: string;
        answer: Answer;
    }
    enum Features {
        PARAGRAPHS = "paragraphs",
        RELATIONS = "relations",
        VECTORS = "vectors"
    }
    interface Answer {
        type: 'answer';
        text: string;
        id: string;
        sources?: Search.FindResults;
        citations?: Citations;
        incomplete?: boolean;
        inError?: boolean;
    }
    enum Author {
        USER = "USER",
        NUCLIA = "NUCLIA"
    }
    interface ContextEntry {
        author: Author;
        text: string;
    }
}
interface Citations {
    [paragraphId: string]: {
        start: number;
        end: number;
    }[];
}

declare function chat(nuclia: INuclia, path: string, query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions): Observable<Chat.Answer | IErrorResponse>;

interface ReadableResource extends IResource {
}
/**
 * Implements all the read operations on resources.
 *
 * A resource allows you to store content in the Knowledge Box.
 * A single resource might contain several fields.
 *
 * Fields have different types: files, links, texts, conversations, etc.
 */
declare class ReadableResource implements IResource {
    data: ResourceData;
    private fieldTextsCache;
    /**
     * Note: Usually you will not need to create a `Resource` object yourself.
     * It is returned by the `getResource` method of the `KnowledgeBox` object. */
    constructor(data: IResource);
    getFields<T = IFieldData>(types?: (keyof ResourceData)[]): T[];
    getFieldData<T = IFieldData>(type: keyof ResourceData, fieldId: string): T | undefined;
    /** Returns the summaries generated by Nuclia for every resource fields. */
    getExtractedSummaries(): string[];
    /** Returns the texts generated by Nuclia for every resource fields. */
    getExtractedTexts(): ExtractedText[];
    /** Returns the files contained in the resource. */
    getFiles(): CloudLink[];
    /** Returns the thumbnails generated by Nuclia for every resource fields. */
    getThumbnails(): CloudLink[];
    getAnnotatedEntities(): {
        [key: string]: string[];
    };
    /** Returns the entities extracted from the resource. */
    getNamedEntities(): {
        [key: string]: string[];
    };
    getClassifications(): Classification[];
    getPositionedNamedEntities(fieldType: keyof ResourceData, fieldId: string): PositionedNER[];
    private formatTitle;
    getParagraphText(fieldType: FIELD_TYPE, fieldId: string, paragraph: Paragraph): string;
    getSentenceText(fieldType: FIELD_TYPE, fieldId: string, sentence: Sentence): string;
    private getFieldText;
}
/** Extends `ReadableResource` and implements all the write operations. */
declare class Resource extends ReadableResource implements IResource {
    kb: string;
    uuid: string;
    private nuclia;
    get kbPath(): string;
    get path(): string;
    constructor(nuclia: INuclia, kb: string, data: IResource);
    /**
     * Modifies the resource attributes.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) => knowledgeBox.getResource('my-resource')),
          switchMap((resource) => resource.modify({ description: 'new description' })),
        )
        .subscribe(() => {
          console.log('resource modified');
        });
      ```
     */
    modify(data: Partial<ICreateResource>, synchronous?: boolean): Observable<void>;
    /** Deletes the resource. */
    delete(synchronous?: boolean): Observable<void>;
    /** Triggers a resource reprocessing. */
    reprocess(): Observable<void>;
    getField(type: FIELD_TYPE, field: string, show?: ResourceFieldProperties[], extracted?: ExtractedDataTypes[]): Observable<ResourceField>;
    /** Returns the thumbnails generated by Nuclia for every resource fields as `blob:` URLs. */
    getThumbnailsUrl(): Observable<string[]>;
    /** Deletes the field with the given type and id. */
    deleteField(type: FIELD_TYPE, field: string, synchronous?: boolean): Observable<void>;
    /**
     * Adds or updates a field in the resource.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.getResource('my-resource').pipe(
              switchMap((resource) =>
                resource.setField(FIELD_TYPE.text, 'my-field', {
                  body: '*my text*',
                  format: 'MARKDOWN',
                }),
              ),
            ),
          ),
        )
        .subscribe(() => {
          console.log('field added');
        });
      ```
    */
    setField(type: FIELD_TYPE, field: string, data: TextField | LinkField | FileField | KeywordSetField): Observable<void>;
    /**
     * Uploads a file in the resource. The field will be stored in the indicated field.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) => knowledgeBox.getResource('my-resource')),
          switchMap((resource) => resource.upload(fileInputElement.files[0])),
        )
        .subscribe(() => {
          console.log('file uploaded');
        });
      ```
    */
    upload(field: string, file: File, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(field: string, buffer: ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    /**
     * Uploads a list of files in the resource. It automatically creates a new field for each file (named according to the filename).
     * It uses the [TUS](https://tus.io/) protocol to upload the files. */
    batchUpload(files: FileList | File[]): Observable<UploadStatus>;
    /** Performs a search operation in the resource (similar as `find()` but results are not nested). */
    search(query: string, features?: Search.ResourceFeatures[], options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /** Performs a find operation in the resource. */
    find(query: string, features?: Search.ResourceFeatures[], options?: SearchOptions): Observable<Search.FindResults | IErrorResponse>;
    setLabels(fieldId: string, fieldType: string, paragraphId: string, labels: Classification[]): Observable<void>;
    setEntities(fieldId: string, fieldType: string, entities: TokenAnnotation[]): Observable<void>;
}

declare const deDuplicateList: (a: any[]) => any[];
declare const setLabels: (fieldId: string, fieldType: string, paragraphId: string, labels: Classification[], allEntries: UserFieldMetadata[]) => UserFieldMetadata[];
declare const setEntities: (fieldId: string, fieldType: string, tokens: TokenAnnotation[], allEntries: UserFieldMetadata[]) => UserFieldMetadata[];
declare const sliceUnicode: (str: string | string[] | undefined, start?: number, end?: number) => string;
declare const lengthUnicode: (str: string | undefined) => number;

interface AlgoliaRecord {
    title?: string;
    fullText?: string[];
    images?: string[];
}
declare const resourceToAlgoliaFormat: (resource: Resource, backend: string) => AlgoliaRecord;
/**
 * Currently in our models, there are more FIELD_TYPEs than ResourceData keys, so we need the switch for typing reason
 */
declare const getDataKeyFromFieldType: (fieldType: FIELD_TYPE) => keyof ResourceData | null;
declare function longToShortFieldType(fieldType: FIELD_TYPE): SHORT_FIELD_TYPE;
declare function shortToLongFieldType(shortType: SHORT_FIELD_TYPE): FIELD_TYPE | null;
declare function getFieldTypeFromString(type: string): FIELD_TYPE | null;

type NotificationType = 'resource_written' | 'resource_processed' | 'resource_indexed';
type NotificationOperation = 'created' | 'modified' | 'deleted';
interface BaseNotificationData {
    resource_uuid: string;
    resource_title: string;
    seqid: number;
}
interface ResourceWrittenData extends BaseNotificationData {
    operation: NotificationOperation;
    error: boolean;
}
interface ResourceProcessedData extends BaseNotificationData {
    ingestion_succeeded: boolean;
    processing_errors: boolean;
}
interface NotificationMessage {
    type: NotificationType;
    data: BaseNotificationData | ResourceWrittenData | ResourceProcessedData;
}

declare function getAllNotifications(nuclia: INuclia, path: string, controller: AbortController): Observable<NotificationMessage[]>;

type KBStates = 'PUBLISHED' | 'PRIVATE';
type KBRoles = 'SOWNER' | 'SCONTRIBUTOR' | 'SMEMBER';
declare enum LabelSetKind {
    RESOURCES = "RESOURCES",
    PARAGRAPHS = "PARAGRAPHS",
    SELECTIONS = "SELECTIONS"
}
declare enum EventType {
    VISITED = "VISITED",
    MODIFIED = "MODIFIED",
    DELETED = "DELETED",
    NEW = "NEW",
    STARTED = "STARTED",
    STOPPED = "STOPPED",
    SEARCH = "SEARCH",
    PROCESSED = "PROCESSED",
    CHAT = "CHAT"
}
interface IKnowledgeBoxCreation {
    id: string;
    slug?: string;
    title?: string;
    state?: KBStates;
    description?: string;
    zone: string;
    uuid?: string;
}
interface IKnowledgeBoxItem extends IKnowledgeBoxCreation {
    role_on_kb?: KBRoles;
}
interface IStandaloneKb {
    slug: string;
    uuid: string;
}
interface FullKbUser {
    id: string;
    name: string;
    email: string;
    role: KBRoles;
}
interface KbUser {
    id: string;
    role: KBRoles;
}
interface KbUserPayload {
    add?: KbUser[];
    update?: KbUser[];
    delete?: string[];
}
interface InviteKbData {
    email: string;
    role: KBRoles;
}
interface KbInvite {
    email: string;
    role: KBRoles;
    expires: string;
}
interface IKnowledgeBox extends IKnowledgeBoxCreation {
    get path(): string;
    get fullpath(): string;
    getEntities(): Observable<Entities>;
    getEntitiesGroup(groupId: string): Observable<EntitiesGroup>;
    getSynonyms(): Observable<Synonyms>;
    getLabels(): Observable<LabelSets>;
    getResource(uuid: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<IResource>;
    getResourceBySlug(slug: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<IResource>;
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions): Observable<Chat.Answer | IErrorResponse>;
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions, callback?: (answer: Chat.Answer | IErrorResponse) => void): Observable<Chat.Answer | IErrorResponse>;
    find(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.FindResults | IErrorResponse>;
    search(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    summarize(ressourceIds: string[]): Observable<string>;
    tokens(text: string): Observable<SentenceToken[]>;
    generate(question: string, context: string[]): Observable<{
        answer: string;
        cannotAnswer: boolean;
    }>;
    rephrase(question: string): Observable<string>;
    generateRandomQuestionAboutResource(resource: Resource): Observable<string>;
    catalog(query: string, options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    suggest(query: string): Observable<Search.Suggestions | IErrorResponse>;
    feedback(answerId: string, good: boolean): Observable<void>;
    listFeedback(): Observable<string[]>;
    counters(): Observable<Counters>;
    listResources(page?: number, size?: number): Observable<ResourceList>;
    getTempToken(): Observable<string>;
    listActivity(type?: EventType, page?: number, size?: number): Observable<EventList>;
    listActivityDownloads(type: EventType): Observable<ActivityDownloadList>;
    downloadActivity(type: EventType, month: string): Observable<Blob>;
    getConfiguration(): Observable<{
        [id: string]: any;
    }>;
    getLearningSchema(): Observable<LearningConfigurations>;
    getUsers(accountSlug: string): Observable<FullKbUser[]>;
    listenToAllNotifications(): Observable<NotificationMessage[]>;
    listenToProcessingNotifications(): Observable<ResourceProcessingNotification[]>;
    listenToResourceOperationNotifications(): Observable<ResourceOperationNotification[]>;
    stopListeningToNotifications(): void;
    processingStatus(cursor?: string, scheduled?: boolean, limit?: number): Observable<{
        cursor: string;
        results: ProcessingStatus[];
    }>;
}
interface IWritableKnowledgeBox extends IKnowledgeBox {
    admin?: boolean;
    contrib?: boolean;
    modify(data: Partial<IKnowledgeBox>): Observable<void>;
    publish(published: boolean): Observable<void>;
    delete(): Observable<void>;
    createEntitiesGroup(groupId: string, group: EntitiesGroup): Observable<void>;
    updateEntitiesGroup(groupId: string, payload: UpdateEntitiesGroupPayload): Observable<void>;
    deleteEntitiesGroup(groupId: string): Observable<void>;
    setLabelSet(setId: string, labelSet: LabelSet): Observable<void>;
    deleteLabelSet(setId: string): Observable<void>;
    setSynonyms(synonyms: Synonyms): Observable<void>;
    deleteAllSynonyms(): Observable<void>;
    createResource(resource: IResource, synchronous: boolean): Observable<{
        uuid: string;
    }>;
    createLinkResource(link: LinkField, metadata?: UserMetadata, synchronous?: boolean, origin?: Origin): Observable<{
        uuid: string;
    }>;
    upload(file: File | FileWithMetadata, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(buffer: ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(data: File | FileWithMetadata | ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    batchUpload(files: FileList | File[] | FileWithMetadata[]): Observable<UploadStatus>;
    getServiceAccounts(): Observable<ServiceAccount[]>;
    createServiceAccount(data: ServiceAccountCreation): Observable<void>;
    deleteServiceAccount(serviceAccountId: string): Observable<void>;
    createKeyForService(data: ServiceAccountCreation, expires: string): Observable<{
        token: string;
    }>;
    createKey(serviceAccountId: string, expires: string): Observable<{
        token: string;
    }>;
    deleteKey(serviceAccountId: string, serviceAccountKeyId: string): Observable<void>;
    setConfiguration(config: {
        [id: string]: any;
    }): Observable<void>;
    updateUsers(data: KbUserPayload): Observable<void>;
    inviteToKb(data: InviteKbData): Observable<void>;
}
interface KnowledgeBoxCreation {
    slug: string;
    title: string;
    description?: string;
    learning_configuration?: {
        [configId: string]: any;
    };
}
interface Entities {
    [key: string]: BaseEntitiesGroup;
}
interface Entity {
    value: string;
    merged?: boolean;
    represents?: string[];
}
interface BaseEntitiesGroup {
    title?: string;
    color?: string;
    custom?: boolean;
}
interface EntitiesGroup extends BaseEntitiesGroup {
    entities: {
        [key: string]: Entity;
    };
}
interface UpdateEntitiesGroupPayload {
    title?: string;
    color?: string;
    add: {
        [key: string]: Entity;
    };
    update: {
        [key: string]: Entity;
    };
    delete: string[];
}
interface Label {
    title: string;
    related?: string;
    text?: string;
    uri?: string;
}
interface LabelSet {
    title: string;
    color: string;
    multiple: boolean;
    kind: LabelSetKind[];
    labels: Label[];
}
interface LabelSets {
    [id: string]: LabelSet;
}
interface WidgetFeatures {
    editLabels?: boolean;
    entityAnnotation?: boolean;
    filter?: boolean;
    navigateToFile?: boolean;
    navigateToLink?: boolean;
    notPublic?: boolean;
    permalink?: boolean;
    relations?: boolean;
    suggestions?: boolean;
    suggestLabels?: boolean;
    autocompleteFromNERs?: boolean;
    displayMetadata?: boolean;
    answers?: boolean;
    hideLogo?: boolean;
    hideResults?: boolean;
    hideThumbnails?: boolean;
    knowledgeGraph?: boolean;
    useSynonyms?: boolean;
    autofilter?: boolean;
    noBM25forChat?: boolean;
    citations?: boolean;
}
type RAGStrategyName = 'field_extension' | 'full_resource';
interface RAGStrategy {
    name: RAGStrategyName;
    fields?: string[];
}
interface Counters {
    resources: number;
    paragraphs: number;
    fields: number;
    sentences: number;
    index_size: number;
}
interface ResourceList {
    resources: Resource[];
    pagination: ResourcePagination;
}
interface ResourcePagination {
    page: number;
    size: number;
    last: boolean;
}
interface EventList {
    events: Event[];
    pagination: ResourcePagination;
}
type Event = {
    [key: string]: any;
};
interface ActivityDownloadList {
    downloads: string[];
}
interface ServiceAccountKey {
    id: string;
    created: string;
    expires: string;
}
interface ServiceAccount {
    id: string;
    title: string;
    role: KBRoles;
    keys?: ServiceAccountKey[];
}
interface ServiceAccountCreation {
    title: string;
    role: KBRoles;
}
interface SynonymsPayload {
    synonyms: Synonyms;
}
interface Synonyms {
    [main: string]: string[];
}
interface SentenceToken {
    text: string;
    ner: string;
    start: number;
    end: number;
}
interface ProcessingStatus {
    completed: boolean;
    completed_at?: string | null;
    failed: boolean;
    kbid: string;
    processing_id: string;
    resource_id: string;
    retries: number;
    schedule_eta: number;
    schedule_order: number;
    scheduled: boolean;
    scheduled_at: string;
    timestamp: string;
    title: string;
}
interface ResourceBaseNotification {
    resourceId: string;
    resourceTitle: string;
    timestamp: string;
    success: boolean;
}
interface ResourceOperationNotification extends ResourceBaseNotification {
    operation: NotificationOperation;
}
type ResourceProcessingNotification = ResourceBaseNotification;

declare enum TrainingType {
    classifier = "classifier",
    resource_labeler = "resource-labeler",
    paragraph_labeler = "paragraph-labeler",
    ner = "ner"
}
declare enum TrainingStatus {
    finished = "finished",
    not_running = "not_running",
    running = "running",
    started = "started",
    stopped = "stopped"
}
declare enum TrainingExecutionStatus {
    succeeded = "succeeded",
    failed = "failed",
    stopped = "stopped"
}
interface TrainingLastExecution {
    start: string;
    end: string;
    status: TrainingExecutionStatus;
}
interface TrainingTask {
    task: string;
    status: TrainingStatus;
    last_execution?: TrainingLastExecution;
}
interface TrainingExecutions {
    items: TrainingExecution[];
    pagination: {
        page: number;
        size: number;
        last: boolean;
    };
}
interface TrainingExecution {
    id: string;
    task: string;
    start: string;
    end: string;
    status: TrainingExecutionStatus;
}
interface TrainingExecutionWithDuration extends TrainingExecution {
    duration: string;
}

declare class Training {
    kb: WritableKnowledgeBox;
    nuclia: INuclia;
    constructor(kb: WritableKnowledgeBox, nuclia: INuclia);
    start(type: TrainingType, params?: {
        valid_nertags?: string[];
        valid_labelsets?: string[];
    }): Observable<TrainingTask>;
    stop(type: TrainingType): Observable<TrainingTask>;
    getStatus(type: TrainingType): Observable<TrainingTask>;
    getExecutions(page?: number): Observable<TrainingExecutions>;
    hasModel(type: TrainingType): Observable<boolean>;
}

interface KnowledgeBox extends IKnowledgeBox {
}
/**
 * Provides access to all the Knowledge Box contents and services in read mode.
 *
 * For any Knowledge Box operation that requires write access, you need to use `WritableKnowledgeBox` instead.
 */
declare class KnowledgeBox implements IKnowledgeBox {
    accountId: string;
    protected nuclia: INuclia;
    private tempToken?;
    private notifications?;
    private notificationsController?;
    private resourceProcessingStatus;
    private resourceOperationStatus;
    /**
     * The Knowledge Box path on the regional API.
     *
     * Example: `/v1/kb/3cce4a71-9cb9-4fda-beee-8a1512616bf0`
     */
    get path(): string;
    /**
     * The Knowledge Box fullpath on the regional API.
     *
     * Example: `https://europe-1.nuclia.cloud/api/v1/kb/3cce4a71-9cb9-4fda-beee-8a1512616bf0`
     */
    get fullpath(): string;
    constructor(nuclia: INuclia, account: string, data: IKnowledgeBoxCreation);
    /** Returns all the NER families defined in the Knowledge Box. */
    getEntities(): Observable<Entities>;
    /** Returns the NER family with the given id. */
    getEntitiesGroup(groupId: string): Observable<EntitiesGroup>;
    getSynonyms(): Observable<Synonyms>;
    /** Returns all the labels defined in the Knowledge Box. */
    getLabels(): Observable<LabelSets>;
    /**
     * Retrieves a resource from the Knowledge Box.
     *
     * - `show` defines which properties are returned. Default takes all the following properties
     * and may result in a large response:
     *   - `ResourceProperties.BASIC`
     *   - `ResourceProperties.ORIGIN`
     *   - `ResourceProperties.RELATIONS`
     *   - `ResourceProperties.VALUES`
     *   - `ResourceProperties.EXTRACTED`
     *   - `ResourceProperties.ERRORS`
     *
     *  - `extracted` defines which extracted data are returned
     * (it is ignored if `ResourceProperties.EXTRACTED` is not in the returned properties). Default takes the following:
     *   - `ExtractedDataTypes.TEXT`
     *   - `ExtractedDataTypes.METADATA`
     *   - `ExtractedDataTypes.LINK`
     *   - `ExtractedDataTypes.FILE`
     *
     *   Other possible values are `ExtractedDataTypes.LARGE_METADATA` and `ExtractedDataTypes.VECTOR` (Note: they may significantly increase the response size).
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox()
        .pipe(switchMap((knowledgeBox) => knowledgeBox.getResource('09a94719a6444c5a9689394f6ed9baf6')))
        .subscribe((resource) => {
          console.log('resource', resource);
        });
      ```
     */
    getResource(uuid: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<Resource>;
    getResourceBySlug(slug: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<Resource>;
    private _getResource;
    private _getPath;
    getResourceFromData(data: IResource): Resource;
    /**
     * Retrieves a generative answer for the given query.
     *
     * The generative answer is a text that is generated chunk by chunk by the language model.
     * It is retrieved through a readable HTTP stream, so the `chat()` method returns an `Observable`
     * emitting a value each time a new chunk is available.
     * The `incomplete` attribute of the emitted value indicates if the asnwer is complete or not.
     *
     * Example:
     ```ts
      nuclia.knowledgeBox
        .chat('where does the Little Prince live')
        .pipe(filter((answer) => !answer.incomplete))
        .subscribe((answer) => {
          console.log(answer.text);
        });
      ```
    */
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions): Observable<Chat.Answer | IErrorResponse>;
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions, callback?: (answer: Chat.Answer | IErrorResponse) => void): Observable<null>;
    /**
     * Performs a find operation in the Knowledge Box, which is the recommended way to search for results.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .find('where does the Little Prince live')
        .subscribe((searchResult) => {
          console.log('search result', searchResult);
        });
      ```
    */
    find(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.FindResults | IErrorResponse>;
    /**
     * Performs a search operation in the knowledge box.
     *
     * It is similar to `find()` but the results are not nested.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .search('where does the Little Prince live', [Search.Features.PARAGRAPH])
        .subscribe((searchResult) => {
          console.log('search result', searchResult);
        });
      ```
    */
    search(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /**
     * Summarize resources.
     *
     * It reads the resources text content and return a global summary about them and one summery per resource.
     *
     * The optional `user_prompt` parameter allows you to specify a text that will be used to generate the summary,
     * and must use the `{text}` placeholder to indicate where the resource text should be inserted
     * (example: 'Make a one-line summary of the following text: {text}').
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .summarize(['09a94719a6444c5a9689394f6ed9baf6'])
        .subscribe((summary) => {
          console.log('Summary', summary);
        });
      ```
    */
    summarize(ressourceIds: string[], user_prompt?: string, generative_model?: string): Observable<string>;
    /**
     * Performs a tokenization of the given text.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .tokens('Does James Joyce live in Dublin?')
        .subscribe((tokens) => {
          console.log('tokens', tokens);
        });
      ```
    */
    tokens(text: string): Observable<SentenceToken[]>;
    /**
     * Performs a question answering operation based on a given context.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .generate('Who is Eric from Toronto?', [
          'Eric is a taxi driver',
          'Eric was born in France',
          'Eric lives in Toronto',
        ]))
        .subscribe((answer) => {
          console.log('answer', answer);
        });
      ```
    */
    generate(question: string, context?: string[]): Observable<{
        answer: string;
        cannotAnswer: boolean;
    }>;
    /**
     * Performs a question rephrasing operation.
     * It returns a rephrased question that can be used as input for the `generate()` method.
     * Example:
      ```ts
      nuclia.knowledgeBox
      .rephrase('Eric lives Toronto')
      .subscribe((rephrased) => {
        console.log('rephrased', rephrased); // Where does Eric live?
      });
      ```
    */
    rephrase(question: string): Observable<string>;
    /**
     * Generates a random question about the given resource.
     * It picks an entities relation from the extracted metadata and generates a question about it.
     * It returns an empty string if no question can be generated.
     * Example:
       ```ts
        nuclia.knowledgeBox
        .getResource('09a94719a6444c5a9689394f6ed9baf6', [ResourceProperties.EXTRACTED], [ExtractedDataTypes.METADATA])
        .pipe(
          switchMap((resource) => knowledgeBox.generateRandomQuestionAboutResource(resource)),
        )
        .subscribe((question) => {
          console.log('question', question);
        });
      ```
    */
    generateRandomQuestionAboutResource(resource: Resource): Observable<string>;
    catalog(query: string, options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /** Suggests paragraphs based on the given query. */
    suggest(query: string, inTitleOnly?: boolean, features?: Search.SuggestionFeatures[]): Observable<Search.Suggestions | IErrorResponse>;
    feedback(answerId: string, good: boolean): Observable<void>;
    listFeedback(): Observable<string[]>;
    /** Returns totals for each kind of contents stored in the Knowledge Box (resources, fields, paragraphs, vectors) */
    counters(): Observable<Counters>;
    /** Lists all the resources stored in the Knowledge Box. */
    listResources(page?: number, size?: number): Observable<ResourceList>;
    /**
     * Returns an ephemeral token.
     * Requires account id and zone to be set in the Nuclia options (except when working with a local NucliaDB instance).
     *
     * This is useful when displaying a clickable link to a file in a private Knowledge Box
     * (the token will authorize the request even though there are no authentication headers).
     *
     * Example:
      ```ts
      const downloadLink = `${nuclia.rest.getFullpath(filePath)}?eph-token=${nuclia.knowledgeBox.getTempToken()}`;
      ```
     */
    getTempToken(): Observable<string>;
    /**
     * @deprecated
     */
    listActivity(type?: EventType, page?: number, size?: number): Observable<EventList>;
    listActivityDownloads(type: EventType): Observable<ActivityDownloadList>;
    downloadActivity(type: EventType, month: string): Observable<Blob>;
    getConfiguration(): Observable<{
        [id: string]: any;
    }>;
    getLearningSchema(): Observable<LearningConfigurations>;
    getUsers(accountSlug: string): Observable<FullKbUser[]>;
    getInvites(): Observable<KbInvite[]>;
    /**
     * Start listening to all the notifications sent by the Knowledge Box.
     */
    listenToAllNotifications(): Observable<NotificationMessage[]>;
    /**
     * Stop listening the notifications sent by the Knowledge Box.
     */
    stopListeningToNotifications(): void;
    /**
     * Start listening to the Knowledge Box notifications, and returns the list of notifications corresponding to the different operations affecting the resources:
     * created, modified, deleted.
     * The notification contains the resource id, title, a timestamp and a flag indicating if the operation was successful or not.
     */
    listenToResourceOperationNotifications(): Observable<ResourceOperationNotification[]>;
    /**
     * Start listening to the Knowledge Box notifications, and returns the list of notifications for resources which have processing completed (either successfully or not).
     * Notifications are sent anytime processing is completed, and processing is done anytime the resource is created or modified (like when a summary is added to the resource for example).
     */
    listenToProcessingNotifications(): Observable<ResourceProcessingNotification[]>;
    processingStatus(cursor?: string, scheduled?: boolean, limit?: number): Observable<{
        cursor: string;
        results: ProcessingStatus[];
    }>;
}
/** Extends `KnowledgeBox` with all the write operations. */
declare class WritableKnowledgeBox extends KnowledgeBox implements IWritableKnowledgeBox {
    /** True if the current user is an administrator of the Knowledge Box. */
    admin?: boolean;
    /** True if the current user is a contributor of the Knowledge Box. */
    contrib?: boolean;
    private _training?;
    get training(): Training;
    /**
     * Modifies the Knowledge Box properties.
     *
     * Example:
      ```ts
      nuclia.db.getKnowledgeBox("my-account", "my-kb").pipe(
        switchMap((knowledgeBox) => knowledgeBox.modify({title: "My new title"}),
      ).subscribe(() => {
        console.log("knowledge box modified");
      });
      ```
    */
    modify(data: Partial<IKnowledgeBox>): Observable<void>;
    /** Deletes the Knowledge Box. */
    delete(): Observable<void>;
    protected getKbEndpointAndZone(): {
        endpoint: string;
        zone: string | undefined;
    };
    /** Publishes or unpublishes the Knowledge Box. */
    publish(published: boolean): Observable<void>;
    /** Creates a new NER family. */
    createEntitiesGroup(groupId: string, group: EntitiesGroup): Observable<void>;
    /** Updates a NER family. */
    updateEntitiesGroup(groupId: string, payload: UpdateEntitiesGroupPayload): Observable<void>;
    /** Deletes a NER family. */
    deleteEntitiesGroup(groupId: string): Observable<void>;
    /**
     * Creates or updates a label set.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.setLabelSet('status', {
              title: 'Status',
              color: '#ff0000',
              labels: [{ title: 'Major' }, { title: 'Minor' }, { title: 'Critical' }],
            }),
          ),
        )
        .subscribe(() => {
          console.log('label set set');
        });
      ```
    */
    setLabelSet(setId: string, labelSet: LabelSet): Observable<void>;
    /** Deletes a label set. */
    deleteLabelSet(setId: string): Observable<void>;
    setSynonyms(synonyms: Synonyms): Observable<void>;
    deleteAllSynonyms(): Observable<void>;
    /** Creates and indexes a new resource in the Knowledge Box. */
    createResource(resource: ICreateResource, synchronous?: boolean): Observable<{
        uuid: string;
    }>;
    /**
     * Creates a new link resource in the Knowledge Box more easily than using `createResource`.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.createLinkResource(
              {
                uri: 'https://en.wikipedia.org/wiki/Hedy_Lamarr',
              },
              { classifications: [{ labelset: 'Genius', label: 'Inventor' }] },
            ),
          ),
        )
        .subscribe(() => {
          console.log('resource created');
        });
      ```
    */
    createLinkResource(link: LinkField, metadata?: UserMetadata, synchronous?: boolean, origin?: Origin): Observable<{
        uuid: string;
    }>;
    /** Checks if a resource exists for the given slug. */
    hasResource(slug: string): Observable<boolean>;
    /**
     * Creates a resource or updates it if it already exists
     */
    createOrUpdateResource(data: ICreateResource, synchronous?: boolean): Observable<{
        uuid: string;
    } | void>;
    /**
     * Uploads a file to the Knowledge Box and automatically creates a new resource to store the file.
     * The resource path is returned in the `resource` property of the `UploadResult`
     * (and `field` provides the path to the `FileField`).
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(switchMap((knowledgeBox) => knowledgeBox.upload(fileInputElement.files[0])))
        .subscribe(() => {
          console.log('file uploaded');
        });
      ```
     */
    upload(file: File | FileWithMetadata, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(buffer: ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    /**
     * Uploads a list of files to the Knowledge Box. It automatically creates a new resource for each file
     * and uses the [TUS](https://tus.io/) protocol to upload the files.
     */
    batchUpload(files: FileList | File[] | FileWithMetadata[]): Observable<UploadStatus>;
    getServiceAccounts(): Observable<ServiceAccount[]>;
    createServiceAccount(data: ServiceAccountCreation): Observable<void>;
    deleteServiceAccount(saId: string): Observable<void>;
    createKey(saId: string, expires: string): Observable<{
        token: string;
    }>;
    createKeyForService(data: ServiceAccountCreation, expires: string): Observable<{
        token: string;
    }>;
    deleteKey(saId: string, saKeyId: string): Observable<void>;
    setConfiguration(config: {
        [id: string]: any;
    }): Observable<void>;
    /**
     * Update the list of users of the Knowledge Box, providing the list of users (id and role) to add and/or update, and the list of user ids to delete.
     * @param data
     */
    updateUsers(data: KbUserPayload): Observable<void>;
    /**
     * Invite a user to the Knowledge Box
     * @param data
     */
    inviteToKb(data: InviteKbData): Observable<void>;
    deleteInvite(email: string): Observable<void>;
}

/** Allows you to access Nuclia accounts and/or Nuclia Knowledge Boxes. */
declare class Db implements IDb {
    private nuclia;
    constructor(nuclia: INuclia);
    /** Returns a list of all the accounts which are accessible for the current authenticated user. */
    getAccounts(): Observable<Account[]>;
    /**
     * Returns a list of all the KB indexes (account id, kb id, zone id) for the provided account slug.
     * @param accountSlug
     */
    getKbIndexes(accountSlug: string): Observable<KbIndex[]>;
    /** Creates a new account. */
    createAccount(account: AccountCreation): Observable<Account>;
    /**
     * Modifies account properties.
     *
     * Example:
      ```ts
      nuclia.db.modifyAccount('my-account', { title: 'My account' }).subscribe({
        next: () => {
          console.log('account modified');
        },
        error: (error) => {
          console.error(error);
        },
      });
      ```
    */
    modifyAccount(accountSlug: string, data: AccountModification): Observable<void>;
    /** Deletes an account. */
    deleteAccount(accountSlug: string): Observable<void>;
    /**
     * Returns account status.
     *
     * Example:
      ```ts
      nuclia.db
        .getAccountStatus('my-account')
        .pipe(filter((status) => status.available))
        .subscribe((status) => {
          console.log('account ready');
        });
      ```
     */
    getAccountStatus(accountSlug: string): Observable<AccountStatus>;
    /**
     * Returns user information.
     *
     * Example:
      ```ts
      nuclia.db.getWelcome().subscribe((welcome) => {
        console.log(`Welcome ${welcome.preferences.name}`);
      });
      ```
    */
    getWelcome(): Observable<Welcome>;
    /**
     * Returns the account with the given id or slug, or the one defined in the Nuclia options
     * if no id nor slug is provided.
     */
    getAccount(): Observable<Account>;
    getStandaloneKbs(): Observable<IStandaloneKb[]>;
    /**
     * Returns a list of all the Knowledge Boxes for the given account. Account slug and id can be provided in the Nuclia options or as parameters.
     */
    getKnowledgeBoxes(): Observable<IKnowledgeBoxItem[]>;
    getKnowledgeBoxes(accountSlug: string, accountId: string): Observable<IKnowledgeBoxItem[]>;
    /**
     * Returns the list of Knowledge Boxes for the given account id and zone.
     * @param accountId
     * @param zone
     */
    getKnowledgeBoxesForZone(accountId: string, zone: string): Observable<IKnowledgeBoxItem[]>;
    /**
     * Returns the Knowledge Box corresponding to the account id, Knowledge Box id and zone provided as parameters or the ones defined in the Nuclia options
     * if no parameters are provided.
     * Zone is mandatory except if the Knowledge Box is from a local NucliaDB instance.
     */
    getKnowledgeBox(): Observable<WritableKnowledgeBox>;
    getKnowledgeBox(accountId: string, knowledgeBoxId: string, zone?: string): Observable<WritableKnowledgeBox>;
    /**
     * Creates a new Knowledge Box.
     * Zone parameter is mandatory except if the Knowledge Box is from a local NucliaDB instance.
     * Example:
      ```ts
      const knowledgeBox = {
        slug: 'my-kb',
        title: 'My knowledge box',
      };
      nuclia.db.createKnowledgeBox('my-account-id', 'europe-1', knowledgeBox).subscribe((knowledgeBox) => {
        console.log('knowledge box', knowledgeBox);
      });
      ```
    */
    createKnowledgeBox(accountId: string, knowledgeBox: KnowledgeBoxCreation, zone?: string): Observable<WritableKnowledgeBox>;
    getStats(accountSlug: string, type: StatsType, knowledgeBox?: string, period?: StatsPeriod, utctime?: string): Observable<ProcessingStat[]>;
    /**
     * Uploads and pushes a file to Nuclia Understanding API.
     *
     * _Requires a NUA token._
     *
     * Example:
  
      ```ts
      const file = input.files[0];
      nuclia.db.upload(file).subscribe({
      next: (response) => {
        console.log('file uploaded', response);
      },
      error: (error) => {
        console.error(error);
      },
      });
      ```
     */
    upload(file: FileWithMetadata): Observable<ProcessingPushResponse>;
    /**
     * Pulls the latest data from Nuclia Understanding API.
     *
     * _Requires a NUA token._
     */
    pull(): Observable<ProcessingPullResponse>;
    getProcessingStats(range?: StatsRange, accountId?: string): Observable<ProcessingStat[]>;
    getNUAActivity(accountId: string, client_id: string, zoneSlug: string, pageIndex?: number): Observable<EventList>;
    getNUAClients(accountId: string): Observable<NUAClient[]>;
    getNUAClient(accountId: string, client_id: string, zone: string): Observable<NUAClient>;
    hasNUAClient(): boolean;
    getNUAKey(): string;
    getNUAHeader(): {
        'x-nuclia-nuakey': string;
    };
    /**
     * Creates a NUA client and a NUA token.
     * Zone parameter must be provided except when working with a local NucliaDB instance.
     * @param accountId Account identifier
     * @param data NUA client data
     */
    createNUAClient(accountId: string, data: NUAClientPayload): Observable<{
        client_id: string;
        token: string;
    }>;
    createNUAClient(accountId: string, data: NUAClientPayload, zone: string): Observable<{
        client_id: string;
        token: string;
    }>;
    /**
     *  Renews a NUA token.
     *  Zone parameter must be provided except when working with a local NucliaDB instance.
     */
    renewNUAClient(accountId: string, client_id: string): Observable<{
        client_id: string;
        token: string;
    }>;
    renewNUAClient(accountId: string, client_id: string, zone: string): Observable<{
        client_id: string;
        token: string;
    }>;
    /**
     * Deletes a NUA client.
     * Zone parameter must be provided except when working with a local NucliaDB instance.
     */
    deleteNUAClient(accountId: string, client_id: string): Observable<void>;
    deleteNUAClient(accountId: string, client_id: string, zone: string): Observable<void>;
    /**
     * Get learning configuration schema.
     * When used on Cloud account, this method is requiring account id and zone parameters.
     * When used on standalone, this method doesn't take any parameter
     */
    getLearningSchema(): Observable<LearningConfigurations>;
    getLearningSchema(accountId: string, zone: string): Observable<LearningConfigurations>;
    /**
     * Extract NER tokens from a text.
     */
    predictTokens(text: string): Observable<PredictedToken[]>;
    /**
     * Generate an answer from a question and a context.
     */
    predictAnswer(question: string, context: string[], model?: string): Observable<string>;
    /**
     * Generate a summary from a text.
     *
     * The optional `user_prompt` parameter allows you to provide a custom prompt to the model,
     * it must use the `{text}` placeholder to indicate where the resource text should be inserted
     * (example: 'Make a one-line summary of the following text: {text}').
     */
    predictSummarize(text: string, user_prompt?: string, model?: string, summary_kind?: 'simple' | 'extended'): Observable<string>;
    /**
     * Get an account user by their id
     * @param accountSlug
     * @param userId
     */
    getAccountUser(accountSlug: string, userId: string): Observable<Partial<FullAccountUser>>;
    /**
     * Get the list of all users of an account
     * @param accountSlug
     */
    getAccountUsers(accountSlug: string): Observable<FullAccountUser[]>;
    /**
     * Add and/or delete users from an account
     * @param accountSlug
     * @param users
     */
    setAccountUsers(accountSlug: string, users: AccountUsersPayload): Observable<void>;
    /**
     * Invite a user to an account
     * @param accountSlug
     * @param data
     */
    inviteToAccount(accountSlug: string, data: InviteAccountUserPayload): Observable<void>;
    /**
     * List pending account invitations
     * @param accountId
     */
    getAccountInvitations(accountId: string): Observable<PendingInvitation[]>;
    /**
     * Delete account invitation
     * @param accountId
     * @param email
     */
    deleteAccountInvitation(accountId: string, email: string): Observable<void>;
}

interface INuclia {
    options: NucliaOptions;
    auth: IAuthentication;
    rest: IRest;
    db: IDb;
    events?: IEvents;
    currentShards?: {
        [kb: string]: string[];
    };
    get backend(): string;
    get regionalBackend(): string;
    get knowledgeBox(): KnowledgeBox;
}
interface IEvents {
    emit<T>(eventName: string, data: T): void;
    on<T>(eventName: string): Observable<T>;
}
interface IAuthentication {
    isAuthenticated(): Observable<boolean>;
    hasLoggedOut(): Observable<boolean>;
    login(username: string, password: string, validation?: string): Observable<boolean>;
    logout(): void;
    getAuthHeaders(): {
        [key: string]: string;
    };
    getAuthHeaders(method: string, path: string): {
        [key: string]: string;
    };
    getToken(force?: boolean): string;
    getRefreshToken(): string;
    authenticate(tokens: AuthTokens): boolean;
    setPassword(password: string): Observable<boolean>;
    deleteAuthenticatedUser(): Observable<void>;
    getJWTUser(): JwtUser | null;
}
interface IRest {
    get<T>(path: string, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, zoneSlug?: string): Observable<T>;
    post<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    put<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    patch<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    delete(path: string, extraHeaders?: {
        [key: string]: string;
    }, synchronous?: boolean, zoneSlug?: string): Observable<void>;
    head(path: string, extraHeaders?: {
        [key: string]: string;
    }): Observable<Response>;
    getZones(): Observable<{
        [key: string]: string;
    }>;
    getZoneSlug(zoneId: string): Observable<string>;
    getFullUrl(path: string): string;
    getObjectURL(path: string): Observable<string>;
    getStreamedResponse(path: string, body: any): Observable<{
        data: Uint8Array;
        incomplete: boolean;
        headers: Headers;
    }>;
    getStreamMessages(path: string, controller: AbortController): Observable<{
        data: Uint8Array;
        headers: Headers;
    }>;
    checkAuthorization(path: string): Observable<{
        allowed: boolean;
        roles: (KBRoles | NucliaDBRole)[];
    }>;
}
interface IDb {
    getAccounts(): Observable<Account[]>;
    getKbIndexes(accountSlug: string): Observable<KbIndex[]>;
    createAccount(account: AccountCreation): Observable<Account>;
    getAccountStatus(accountSlug: string): Observable<AccountStatus>;
    modifyAccount(accountSlug: string, data: AccountModification): Observable<void>;
    deleteAccount(accountSlug: string): Observable<void>;
    getWelcome(): Observable<Welcome>;
    getAccount(): Observable<Account>;
    getAccount(accountIdOrSlug?: string): Observable<Account>;
    getStandaloneKbs(): Observable<IStandaloneKb[]>;
    getKnowledgeBoxes(): Observable<IKnowledgeBoxItem[]>;
    getKnowledgeBoxes(accountSlug: string, accountId: string): Observable<IKnowledgeBoxItem[]>;
    getKnowledgeBoxesForZone(accountId: string, zone: string): Observable<IKnowledgeBoxItem[]>;
    getKnowledgeBox(): Observable<WritableKnowledgeBox>;
    getKnowledgeBox(accountId: string, knowledgeBoxId: string, zone?: string): Observable<WritableKnowledgeBox>;
    createKnowledgeBox(accountId: string, knowledgeBox: KnowledgeBoxCreation, zone?: string): Observable<WritableKnowledgeBox>;
    getStats(accountSlug: string, type: StatsType, knowledgeBox?: string, period?: StatsPeriod, utctime?: string): Observable<ProcessingStat[]>;
    upload(file: File): Observable<ProcessingPushResponse>;
    getProcessingStats(range?: StatsRange, accountId?: string): Observable<ProcessingStat[]>;
    pull(): Observable<ProcessingPullResponse>;
    getNUAClients(accountId: string): Observable<NUAClient[]>;
    getNUAClient(accountId: string, client_id: string, zone: string): Observable<NUAClient>;
    createNUAClient(accountId: string, data: NUAClientPayload): Observable<{
        client_id: string;
        token: string;
    }>;
    createNUAClient(accountId: string, data: NUAClientPayload, zone: string): Observable<{
        client_id: string;
        token: string;
    }>;
    renewNUAClient(accountId: string, client_id: string): Observable<{
        client_id: string;
        token: string;
    }>;
    renewNUAClient(accountId: string, client_id: string, zone: string): Observable<{
        client_id: string;
        token: string;
    }>;
    deleteNUAClient(accountId: string, client_id: string): Observable<void>;
    deleteNUAClient(accountId: string, client_id: string, zone: string): Observable<void>;
    hasNUAClient(): boolean;
    getNUAActivity(accountId: string, client_id: string, zoneSlug: string, pageIndex?: number): Observable<EventList>;
    getLearningSchema(): Observable<LearningConfigurations>;
    getLearningSchema(accountId: string, zone: string): Observable<LearningConfigurations>;
    predictTokens(text: string): Observable<PredictedToken[]>;
    predictAnswer(question: string, context: string[], model?: string): Observable<string>;
    predictSummarize(text: string, user_prompt?: string, model?: string, summary_kind?: 'simple' | 'extended'): Observable<string>;
    getAccountUser(accountSlug: string, userId: string): Observable<Partial<FullAccountUser>>;
    getAccountUsers(accountSlug: string): Observable<FullAccountUser[]>;
    setAccountUsers(accountSlug: string, users: AccountUsersPayload): Observable<void>;
    inviteToAccount(accountSlug: string, data: InviteAccountUserPayload): Observable<void>;
    getAccountInvitations(accountId: string): Observable<PendingInvitation[]>;
    deleteAccountInvitation(accountId: string, email: string): Observable<void>;
}
interface NucliaOptions {
    /**
     * The Nuclia backend to use.
     *
     * Example: `https://nuclia.cloud/api` */
    backend: string;
    /**
     * The geographical zone for the regional API calls.
     *
     * Example: `europe-1` */
    zone?: string;
    /**
     * Allows you to make calls to a private Knowledge Box.
     *
     * It can be used in a server-side app, but never in a web app.
     */
    apiKey?: string;
    /**
     * Allows you to make calls the NUA processing.
     */
    nuaKey?: string;
    /**
     * The Nuclia account slug.
     *
     * Example: `my-account`
     */
    account?: string;
    accountType?: AccountTypes;
    /**
     * The Nuclia account id.
     */
    accountId?: string;
    /**
     * The Nuclia Knowledge Box unique id.
     *
     * Example: `17815eb2-06a5-40ee-a5aa-b2f9dbc5da70` */
    knowledgeBox?: string;
    /**
     * The Knowledge Box slug.
     *
     * Example: `my-kb` */
    kbSlug?: string;
    client?: string;
    /** Indicates if you are using a local NucliaDB instance. */
    standalone?: boolean;
    /** Indicates if you are using a proxy. */
    proxy?: boolean;
    /**
     * Indicates if the Knowledge Box is public or not.
     *
     * Set it to `false` when using a private Knowledge Box.
     */
    public?: boolean;
    /**
     * Allow to modify the headers for the REST calls.
     */
    modifyHeaders?: (headers: {
        [key: string]: string;
    }) => {
        [key: string]: string;
    };
}
type PromiseMapper<T> = {
    [K in keyof T]: T[K] extends (...args: infer A) => Observable<infer V> ? (...args: A) => Promise<V> : T[K];
};
interface IErrorResponse {
    status: number;
    detail: string;
    type: 'error';
    body?: any;
}
type AccountRoles = 'AOWNER' | 'AMEMBER';
interface FullAccountUser {
    id: string;
    name: string;
    email: string;
    role: AccountRoles;
}
interface AccountUser {
    id: string;
    role: AccountRoles;
}
interface AccountUsersPayload {
    add?: AccountUser[];
    delete?: string[];
}
interface InviteAccountUserPayload {
    email: string;
    role?: AccountRoles;
}
interface PendingInvitation {
    email: string;
    role: AccountRoles;
    expires: string;
}

interface AuthTokens {
    access_token: string;
    refresh_token: string;
}
type NucliaDBRole = 'READER' | 'WRITER' | 'MANAGER';

/**
 * It manages authentication to the Nuclia backend.
 * It can be based on login/password for account authentication,
 * or on an API key for private Knowledge Box authentication.
 * Authentication is not necessary when using a public Knowledge Box.
 */
declare class Authentication implements IAuthentication {
    private nuclia;
    private _isAuthenticated;
    private timerSubscription?;
    constructor(nuclia: INuclia);
    /**
     * Returns the authentication header (which will be `Authorization` for account authentication, or `X-NUCLIA-SERVICEACCOUNT` for private Knowledge Box authentication).
     *
     * Example:
      ```ts
      const headers = nuclia.auth.getAuthHeaders();
      ```
     */
    getAuthHeaders(): {
        [key: string]: string;
    };
    getAuthHeaders(method: string, path: string): {
        [key: string]: string;
    };
    private getNucliaDbRole;
    /**
     * Emits when the authentication status changes.
     *
     * Example:
      ```ts
      nuclia.auth.isAuthenticated().subscribe((isAuthenticated) => {
        if (isAuthenticated) {
          console.log('You are authenticated');
        } else {
          console.log('You are not authenticated');
        }
      });
      ```
     */
    isAuthenticated(): Observable<boolean>;
    /**
     * Returns an `Observable` emitting when the user has logged out.
     *
     * Example:
      ```ts
      nuclia.auth.hasLoggedOut().subscribe((loggedOut) => {
        if (loggedOut) {
          // do something
        }
      });
      ```
     */
    hasLoggedOut(): Observable<boolean>;
    /**
     * Calls the login endpoint for account authentication and emits when done.
     *
     * It can optionally take a reCaptcha validation code if the Nuclia backend requires it.
     * Once authenticated, the Nuclia SDK will periodically refresh the token before it expires.
     *
     * Example:
      ```ts
      nuclia.auth.login(username, password).subscribe({
        next: (success) => {
          this.loginError = success ? '' : 'Error';
          console.log('logged in', success);
        },
        error: (error) => {
          this.loginError = 'Error';
          console.error(error);
        },
        complete: () => {
          this.pending = false;
        },
      });
      ```
     */
    login(username: string, password: string, validation?: string): Observable<boolean>;
    /**
     * Returns a boolean if successful. Stores authentication tokens in localStorage and triggers `isAuthenticated`.
     *
     * This method is automatically called when using `login` and can be useful when using a custom authentication flow.
     *
     * Example:
        ```ts
        nuclia.auth.authenticate(tokens);
        ```
     */
    authenticate(tokens: AuthTokens): boolean;
    /** Calls the logout endpoint and removes the token stored in localStorage. */
    logout(): void;
    refresh(): Observable<boolean>;
    /** Returns authentication token stored in localStorage. */
    getToken(force?: boolean): string;
    /**
     * Sets the current users password.
     *
     * Example:
      ```ts
      nuclia.auth.setPassword(password).subscribe({
        next: (success) => {
          this.passwordError = success ? '' : 'Error';
          console.log('password set', success);
        },
        error: (error) => {
          this.passwordError = 'Error';
          console.error(error);
        },
        complete: () => {
          this.pending = false;
        },
      });
      ```
     */
    setPassword(password: string): Observable<boolean>;
    /**
     * Deletes current user account and removes stored tokens.
     *
     * Example:
      ```ts
      nuclia.auth.deleteAuthenticatedUser().subscribe(() => {
        console.log('User deleted');
      });
      ```
     */
    deleteAuthenticatedUser(): Observable<void>;
    /**
     * Parses JWT token and returns corresponding user information.
     *
     * Example:
      ```ts
      const user = nuclia.auth.getJWTUser();
      console.log(`Hello ${user?.ext.first_name}!`);
      ```
     */
    getJWTUser(): JwtUser | null;
    /** Returns refresh token stored in localStorage. */
    getRefreshToken(): string;
    private storeTokens;
    private checkTokenExpiration;
    private fetch;
}

declare class Events implements IEvents {
    private messages;
    emit<T>(eventName: string, data: T): void;
    on<T>(eventName: string): Observable<T>;
}

declare class Nuclia implements INuclia {
    options: NucliaOptions;
    /** Allows you to authenticate using username/password or using an API key. */
    auth: IAuthentication;
    /** Allows you to make authenticated REST requests to the Nuclia backend. */
    rest: IRest;
    /** Allows you to access and query the Nuclia database. */
    db: IDb;
    currentShards?: {
        [kb: string]: string[];
    };
    events: Events;
    private readKb?;
    /** The Nuclia global backend URL. */
    get backend(): string;
    /** The Nuclia regional backend URL. */
    get regionalBackend(): string;
    /**
     * Direct access to the current Knowledge Box instance
     * (it returns a Knowledge Box in read mode, and does not work with account authentication). */
    get knowledgeBox(): KnowledgeBox;
    /** Similar to `knowledgeBox`, but the returned object exposes `Promises` instead of RxJS `Observables`. */
    get asyncKnowledgeBox(): PromiseMapper<KnowledgeBox>;
    /**
     * Depending on your use case, you might want to:
     *
     * - Use the Nuclia SDK to access and manage a Nuclia account. In this case you will need to provide the `backend` and `account` options, and you will use **account authentication**.
     * - Use the Nuclia SDK to use a Nuclia Knowledge Box. In this case you will need to provide the `backend`, `knowledgeBox` and `zone` options. You will also either use **knowledge box authentication**, or **no authentication** if the Knowledge Box is public.
     *
     * Example:
  
      ```ts
      const nuclia = new Nuclia({
        backend: 'https://nuclia.cloud/api',
        knowledgeBox: '17815eb2-06a5-40ee-a5aa-b2f9dbc5da70',
        zone: 'europe-1',
      });
      ```
     */
    constructor(options: NucliaOptions);
}

declare const ABORT_STREAMING_REASON = "Stop listening to streaming";
/**
 * Handles the elementary REST requests to the Nuclia backend, setting the appropriate HTTP headers.
 *
 * Its main methods implement the corresponding HTTP verbs (`GET` is `get()`, POST is `post()`, etc.)
 * For each of them, `extraHeaders` is an optional parameter that can be used to add headers to the request.
 *
 * On POST, PUT, PATCH and DELETE, the `synchronous` parameter will make the call synchronous,
 * meaning the response will be returned only when the operation is fully completed. It is `false` by default.
 *
 *
 * The default headers set by `Nuclia.rest` are:
 *
 * - `'content-type': 'application/json'`
 * - `Authorization` or `X-NUCLIA-SERVICEACCOUNT` depending on the type of authentication.
 *
 * The default headers will be overridden by `extraHeaders` if they have the same entries.
 *
 * `doNotParse` is a boolean that can be used to disable the automatic JSON parsing of the response. */
declare class Rest implements IRest {
    private nuclia;
    private zones?;
    private streamErrorAt?;
    constructor(nuclia: INuclia);
    get<T>(path: string, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, zoneSlug?: string): Observable<T>;
    post<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    put<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    patch<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    delete<T>(path: string, extraHeaders?: {
        [key: string]: string;
    }, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    head(path: string, extraHeaders?: {
        [key: string]: string;
    }): Observable<Response>;
    private getHeaders;
    private fetch;
    /**
     *  Returns the full URL of the given path, using the regional or the global Nuclia backend according to the path or the provided zone slug (if any).
     */
    getFullUrl(path: string, zoneSlug?: string, insertAuthorizer?: boolean): string;
    /**
     * Check if the user has access to the given endpoint, and return the corresponding roles.
     * */
    checkAuthorization(endpoint: string): Observable<{
        allowed: boolean;
        roles: (KBRoles | NucliaDBRole)[];
    }>;
    /** Returns a dictionary giving the geographical zones available slugs by unique ids. */
    getZones(): Observable<{
        [key: string]: string;
    }>;
    getZoneSlug(zoneId: string): Observable<string>;
    /**
     * Downloads the file, converts it to a BLOB and returns its `blob:` URL.
     *
     * Use carefully with big files as it can impact the memory.
     */
    getObjectURL(path: string): Observable<string>;
    /**
     * Call an endpoint streaming its response by batch of data,
     * concatenate the data with the batch received previously until the response is marked as completed and then close the connection.
     * @param path
     * @param body body to be passed as parameter to the POST request made
     */
    getStreamedResponse(path: string, body: unknown): Observable<{
        data: Uint8Array;
        incomplete: boolean;
        headers: Headers;
    }>;
    /**
     * Call a long polling HTTP endpoint streaming its response until the connection times out.
     * This method is keeping the connection alive by calling the endpoint again when it times out until the provided controller receives an abort signal
     * (or if the endpoint returns an error unrelated to the timeout).
     *
     * @param path
     * @param controller
     */
    getStreamMessages(path: string, controller: AbortController): Observable<{
        data: Uint8Array;
        headers: Headers;
    }>;
    private fetchStream;
    private concat;
}

export { ABORT_STREAMING_REASON, Account, AccountBlockingState, AccountConfig, AccountCreation, AccountLimits, AccountLimitsPatchPayload, AccountModification, AccountRoles, AccountStatus, AccountTypes, AccountUser, AccountUsersPayload, ActivityDownloadList, AuthTokens, Authentication, BaseEntitiesGroup, BaseNotificationData, BaseSearchOptions, BlockedFeature, Chat, ChatOptions, Citations, Classification, CloudLink, ComputedMetadata, ConversationField, ConversationFieldData, Counters, Db, Entities, EntitiesGroup, Entity, EntityPosition, EntityPositions, Event, EventList, EventType, ExtraMetadata, ExtractedData, ExtractedDataTypes, ExtractedText, FIELD_TYPE, FieldClassification, FieldComputedMetadata, FieldFullId, FieldId, FieldMetadata, FileB64, FileExtractedData, FileField, FileFieldData, FileFieldExtractedData, FileMetadata, FilePages, FileUploadStatus, FileWithMetadata, Filter, FilterOperator, FullAccountUser, FullKbUser, IAuthentication, ICreateResource, IDb, IError, IErrorResponse, IEvents, IFieldData, IKnowledgeBox, IKnowledgeBoxCreation, IKnowledgeBoxItem, INuclia, IResource, IRest, IStandaloneKb, IWritableKnowledgeBox, InviteAccountUserPayload, InviteKbData, JwtHelper, JwtUser, KBRoles, KBStates, KbIndex, KbInvite, KbUser, KbUserPayload, KeywordSetField, KeywordSetFieldData, KnowledgeBox, KnowledgeBoxCreation, LABEL_FILTER_PREFIX, Label, LabelSet, LabelSetKind, LabelSets, Language, LearningConfiguration, LearningConfigurationOption, LearningConfigurationSchema, LearningConfigurationSet, LearningConfigurationUserKeys, LearningConfigurations, LinkExtractedData, LinkField, LinkFieldData, LinkFieldExtractedData, Message, MessageAttachment, MessageContent, Metadata, NER_FILTER_PREFIX, NUAClient, NUAClientPayload, NUA_KEY, NestedPosition, NotificationMessage, NotificationOperation, NotificationType, Nuclia, NucliaDBRole, NucliaOptions, NullableUploadLimits, NullableUsageLimits, Origin, PagePositions, PageSelections, PageStructure, PageToken, Paragraph, ParagraphClassification, PendingInvitation, PositionedNER, PredictedToken, ProcessingPullResponse, ProcessingPushResponse, ProcessingStat, ProcessingStatus, PromiseMapper, RAGStrategy, RAGStrategyName, RESOURCE_STATUS, ReadableResource, Relation, RelationEntity, RelationEntityType, RelationType, Resource, ResourceBaseNotification, ResourceData, ResourceField, ResourceFieldProperties, ResourceList, ResourceOperationNotification, ResourcePagination, ResourceProcessedData, ResourceProcessingNotification, ResourceProperties, ResourceStatus, ResourceWrittenData, Rest, Row, RowsPreview, SHORT_FIELD_TYPE, SUMMARY_PROMPT, Search, SearchOptions, Security, Sentence, SentenceToken, ServiceAccount, ServiceAccountCreation, ServiceAccountKey, Sheet, SortField, SortOption, SortOrder, StatsPeriod, StatsRange, StatsType, Synonyms, SynonymsPayload, TUSuploadFile, TextField, TextFieldData, TextFieldFormat, TextFormat, TokenAnnotation, Training, TrainingExecution, TrainingExecutionStatus, TrainingExecutionWithDuration, TrainingExecutions, TrainingLastExecution, TrainingStatus, TrainingTask, TrainingType, TypeParagraph, USER_PROMPTS, UpdateEntitiesGroupPayload, UploadLimits, UploadLimitsEntries, UploadResponse, UploadStatus, UsageLimits, UsageLimitsEntries, UserClassification, UserFieldMetadata, UserMetadata, UserTokenAnnotation, UserType, VisualSelection, Welcome, WelcomeUser, WidgetFeatures, WritableKnowledgeBox, WriteFileField, batchUpload, catalog, chat, deDuplicateList, find, getAllNotifications, getDataKeyFromFieldType, getEntityFromFilter, getFieldTypeFromString, getFileMetadata, getFilterFromEntity, getFilterFromLabel, getFilterFromLabelSet, getLabelFromFilter, getLabelSetFromFilter, lengthUnicode, longToShortFieldType, normalizeSchemaProperty, resourceToAlgoliaFormat, search, setEntities, setLabels, shortToLongFieldType, sliceUnicode, suggest, upload, uploadFile, uploadToProcess };
