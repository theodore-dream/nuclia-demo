import { Observable } from 'rxjs';
import { ActivityDownloadList, Counters, Entities, EntitiesGroup, EventList, EventType, FullKbUser, IKnowledgeBox, IKnowledgeBoxCreation, InviteKbData, IWritableKnowledgeBox, KbInvite, KbUserPayload, LabelSet, LabelSets, ProcessingStatus, ResourceList, ResourceOperationNotification, ResourceProcessingNotification, SentenceToken, ServiceAccount, ServiceAccountCreation, Synonyms, UpdateEntitiesGroupPayload } from './kb.models';
import type { IErrorResponse, INuclia } from '../../models';
import { ExtractedDataTypes, ICreateResource, IResource, LinkField, Origin, Resource, UserMetadata } from '../resource';
import type { UploadResponse } from '../upload';
import { FileMetadata, FileWithMetadata, UploadStatus } from '../upload';
import { Chat, ChatOptions, Search, SearchOptions } from '../search';
import { Training } from '../training';
import { LearningConfigurations, ResourceProperties } from '../db.models';
import { NotificationMessage } from '../notifications';
export interface KnowledgeBox extends IKnowledgeBox {
}
/**
 * Provides access to all the Knowledge Box contents and services in read mode.
 *
 * For any Knowledge Box operation that requires write access, you need to use `WritableKnowledgeBox` instead.
 */
export declare class KnowledgeBox implements IKnowledgeBox {
    accountId: string;
    protected nuclia: INuclia;
    private tempToken?;
    private notifications?;
    private notificationsController?;
    private resourceProcessingStatus;
    private resourceOperationStatus;
    /**
     * The Knowledge Box path on the regional API.
     *
     * Example: `/v1/kb/3cce4a71-9cb9-4fda-beee-8a1512616bf0`
     */
    get path(): string;
    /**
     * The Knowledge Box fullpath on the regional API.
     *
     * Example: `https://europe-1.nuclia.cloud/api/v1/kb/3cce4a71-9cb9-4fda-beee-8a1512616bf0`
     */
    get fullpath(): string;
    constructor(nuclia: INuclia, account: string, data: IKnowledgeBoxCreation);
    /** Returns all the NER families defined in the Knowledge Box. */
    getEntities(): Observable<Entities>;
    /** Returns the NER family with the given id. */
    getEntitiesGroup(groupId: string): Observable<EntitiesGroup>;
    getSynonyms(): Observable<Synonyms>;
    /** Returns all the labels defined in the Knowledge Box. */
    getLabels(): Observable<LabelSets>;
    /**
     * Retrieves a resource from the Knowledge Box.
     *
     * - `show` defines which properties are returned. Default takes all the following properties
     * and may result in a large response:
     *   - `ResourceProperties.BASIC`
     *   - `ResourceProperties.ORIGIN`
     *   - `ResourceProperties.RELATIONS`
     *   - `ResourceProperties.VALUES`
     *   - `ResourceProperties.EXTRACTED`
     *   - `ResourceProperties.ERRORS`
     *
     *  - `extracted` defines which extracted data are returned
     * (it is ignored if `ResourceProperties.EXTRACTED` is not in the returned properties). Default takes the following:
     *   - `ExtractedDataTypes.TEXT`
     *   - `ExtractedDataTypes.METADATA`
     *   - `ExtractedDataTypes.LINK`
     *   - `ExtractedDataTypes.FILE`
     *
     *   Other possible values are `ExtractedDataTypes.LARGE_METADATA` and `ExtractedDataTypes.VECTOR` (Note: they may significantly increase the response size).
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox()
        .pipe(switchMap((knowledgeBox) => knowledgeBox.getResource('09a94719a6444c5a9689394f6ed9baf6')))
        .subscribe((resource) => {
          console.log('resource', resource);
        });
      ```
     */
    getResource(uuid: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<Resource>;
    getResourceBySlug(slug: string, show?: ResourceProperties[], extracted?: ExtractedDataTypes[]): Observable<Resource>;
    private _getResource;
    private _getPath;
    getResourceFromData(data: IResource): Resource;
    /**
     * Retrieves a generative answer for the given query.
     *
     * The generative answer is a text that is generated chunk by chunk by the language model.
     * It is retrieved through a readable HTTP stream, so the `chat()` method returns an `Observable`
     * emitting a value each time a new chunk is available.
     * The `incomplete` attribute of the emitted value indicates if the asnwer is complete or not.
     *
     * Example:
     ```ts
      nuclia.knowledgeBox
        .chat('where does the Little Prince live')
        .pipe(filter((answer) => !answer.incomplete))
        .subscribe((answer) => {
          console.log(answer.text);
        });
      ```
    */
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions): Observable<Chat.Answer | IErrorResponse>;
    chat(query: string, context?: Chat.ContextEntry[], features?: Chat.Features[], options?: ChatOptions, callback?: (answer: Chat.Answer | IErrorResponse) => void): Observable<null>;
    /**
     * Performs a find operation in the Knowledge Box, which is the recommended way to search for results.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .find('where does the Little Prince live')
        .subscribe((searchResult) => {
          console.log('search result', searchResult);
        });
      ```
    */
    find(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.FindResults | IErrorResponse>;
    /**
     * Performs a search operation in the knowledge box.
     *
     * It is similar to `find()` but the results are not nested.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .search('where does the Little Prince live', [Search.Features.PARAGRAPH])
        .subscribe((searchResult) => {
          console.log('search result', searchResult);
        });
      ```
    */
    search(query: string, features?: Search.Features[], options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /**
     * Summarize resources.
     *
     * It reads the resources text content and return a global summary about them and one summery per resource.
     *
     * The optional `user_prompt` parameter allows you to specify a text that will be used to generate the summary,
     * and must use the `{text}` placeholder to indicate where the resource text should be inserted
     * (example: 'Make a one-line summary of the following text: {text}').
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .summarize(['09a94719a6444c5a9689394f6ed9baf6'])
        .subscribe((summary) => {
          console.log('Summary', summary);
        });
      ```
    */
    summarize(ressourceIds: string[], user_prompt?: string, generative_model?: string): Observable<string>;
    /**
     * Performs a tokenization of the given text.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .tokens('Does James Joyce live in Dublin?')
        .subscribe((tokens) => {
          console.log('tokens', tokens);
        });
      ```
    */
    tokens(text: string): Observable<SentenceToken[]>;
    /**
     * Performs a question answering operation based on a given context.
     *
     * Example:
      ```ts
      nuclia.knowledgeBox
        .generate('Who is Eric from Toronto?', [
          'Eric is a taxi driver',
          'Eric was born in France',
          'Eric lives in Toronto',
        ]))
        .subscribe((answer) => {
          console.log('answer', answer);
        });
      ```
    */
    generate(question: string, context?: string[]): Observable<{
        answer: string;
        cannotAnswer: boolean;
    }>;
    /**
     * Performs a question rephrasing operation.
     * It returns a rephrased question that can be used as input for the `generate()` method.
     * Example:
      ```ts
      nuclia.knowledgeBox
      .rephrase('Eric lives Toronto')
      .subscribe((rephrased) => {
        console.log('rephrased', rephrased); // Where does Eric live?
      });
      ```
    */
    rephrase(question: string): Observable<string>;
    /**
     * Generates a random question about the given resource.
     * It picks an entities relation from the extracted metadata and generates a question about it.
     * It returns an empty string if no question can be generated.
     * Example:
       ```ts
        nuclia.knowledgeBox
        .getResource('09a94719a6444c5a9689394f6ed9baf6', [ResourceProperties.EXTRACTED], [ExtractedDataTypes.METADATA])
        .pipe(
          switchMap((resource) => knowledgeBox.generateRandomQuestionAboutResource(resource)),
        )
        .subscribe((question) => {
          console.log('question', question);
        });
      ```
    */
    generateRandomQuestionAboutResource(resource: Resource): Observable<string>;
    catalog(query: string, options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /** Suggests paragraphs based on the given query. */
    suggest(query: string, inTitleOnly?: boolean, features?: Search.SuggestionFeatures[]): Observable<Search.Suggestions | IErrorResponse>;
    feedback(answerId: string, good: boolean): Observable<void>;
    listFeedback(): Observable<string[]>;
    /** Returns totals for each kind of contents stored in the Knowledge Box (resources, fields, paragraphs, vectors) */
    counters(): Observable<Counters>;
    /** Lists all the resources stored in the Knowledge Box. */
    listResources(page?: number, size?: number): Observable<ResourceList>;
    /**
     * Returns an ephemeral token.
     * Requires account id and zone to be set in the Nuclia options (except when working with a local NucliaDB instance).
     *
     * This is useful when displaying a clickable link to a file in a private Knowledge Box
     * (the token will authorize the request even though there are no authentication headers).
     *
     * Example:
      ```ts
      const downloadLink = `${nuclia.rest.getFullpath(filePath)}?eph-token=${nuclia.knowledgeBox.getTempToken()}`;
      ```
     */
    getTempToken(): Observable<string>;
    /**
     * @deprecated
     */
    listActivity(type?: EventType, page?: number, size?: number): Observable<EventList>;
    listActivityDownloads(type: EventType): Observable<ActivityDownloadList>;
    downloadActivity(type: EventType, month: string): Observable<Blob>;
    getConfiguration(): Observable<{
        [id: string]: any;
    }>;
    getLearningSchema(): Observable<LearningConfigurations>;
    getUsers(accountSlug: string): Observable<FullKbUser[]>;
    getInvites(): Observable<KbInvite[]>;
    /**
     * Start listening to all the notifications sent by the Knowledge Box.
     */
    listenToAllNotifications(): Observable<NotificationMessage[]>;
    /**
     * Stop listening the notifications sent by the Knowledge Box.
     */
    stopListeningToNotifications(): void;
    /**
     * Start listening to the Knowledge Box notifications, and returns the list of notifications corresponding to the different operations affecting the resources:
     * created, modified, deleted.
     * The notification contains the resource id, title, a timestamp and a flag indicating if the operation was successful or not.
     */
    listenToResourceOperationNotifications(): Observable<ResourceOperationNotification[]>;
    /**
     * Start listening to the Knowledge Box notifications, and returns the list of notifications for resources which have processing completed (either successfully or not).
     * Notifications are sent anytime processing is completed, and processing is done anytime the resource is created or modified (like when a summary is added to the resource for example).
     */
    listenToProcessingNotifications(): Observable<ResourceProcessingNotification[]>;
    processingStatus(cursor?: string, scheduled?: boolean, limit?: number): Observable<{
        cursor: string;
        results: ProcessingStatus[];
    }>;
}
/** Extends `KnowledgeBox` with all the write operations. */
export declare class WritableKnowledgeBox extends KnowledgeBox implements IWritableKnowledgeBox {
    /** True if the current user is an administrator of the Knowledge Box. */
    admin?: boolean;
    /** True if the current user is a contributor of the Knowledge Box. */
    contrib?: boolean;
    private _training?;
    get training(): Training;
    /**
     * Modifies the Knowledge Box properties.
     *
     * Example:
      ```ts
      nuclia.db.getKnowledgeBox("my-account", "my-kb").pipe(
        switchMap((knowledgeBox) => knowledgeBox.modify({title: "My new title"}),
      ).subscribe(() => {
        console.log("knowledge box modified");
      });
      ```
    */
    modify(data: Partial<IKnowledgeBox>): Observable<void>;
    /** Deletes the Knowledge Box. */
    delete(): Observable<void>;
    protected getKbEndpointAndZone(): {
        endpoint: string;
        zone: string | undefined;
    };
    /** Publishes or unpublishes the Knowledge Box. */
    publish(published: boolean): Observable<void>;
    /** Creates a new NER family. */
    createEntitiesGroup(groupId: string, group: EntitiesGroup): Observable<void>;
    /** Updates a NER family. */
    updateEntitiesGroup(groupId: string, payload: UpdateEntitiesGroupPayload): Observable<void>;
    /** Deletes a NER family. */
    deleteEntitiesGroup(groupId: string): Observable<void>;
    /**
     * Creates or updates a label set.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.setLabelSet('status', {
              title: 'Status',
              color: '#ff0000',
              labels: [{ title: 'Major' }, { title: 'Minor' }, { title: 'Critical' }],
            }),
          ),
        )
        .subscribe(() => {
          console.log('label set set');
        });
      ```
    */
    setLabelSet(setId: string, labelSet: LabelSet): Observable<void>;
    /** Deletes a label set. */
    deleteLabelSet(setId: string): Observable<void>;
    setSynonyms(synonyms: Synonyms): Observable<void>;
    deleteAllSynonyms(): Observable<void>;
    /** Creates and indexes a new resource in the Knowledge Box. */
    createResource(resource: ICreateResource, synchronous?: boolean): Observable<{
        uuid: string;
    }>;
    /**
     * Creates a new link resource in the Knowledge Box more easily than using `createResource`.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.createLinkResource(
              {
                uri: 'https://en.wikipedia.org/wiki/Hedy_Lamarr',
              },
              { classifications: [{ labelset: 'Genius', label: 'Inventor' }] },
            ),
          ),
        )
        .subscribe(() => {
          console.log('resource created');
        });
      ```
    */
    createLinkResource(link: LinkField, metadata?: UserMetadata, synchronous?: boolean, origin?: Origin): Observable<{
        uuid: string;
    }>;
    /** Checks if a resource exists for the given slug. */
    hasResource(slug: string): Observable<boolean>;
    /**
     * Creates a resource or updates it if it already exists
     */
    createOrUpdateResource(data: ICreateResource, synchronous?: boolean): Observable<{
        uuid: string;
    } | void>;
    /**
     * Uploads a file to the Knowledge Box and automatically creates a new resource to store the file.
     * The resource path is returned in the `resource` property of the `UploadResult`
     * (and `field` provides the path to the `FileField`).
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(switchMap((knowledgeBox) => knowledgeBox.upload(fileInputElement.files[0])))
        .subscribe(() => {
          console.log('file uploaded');
        });
      ```
     */
    upload(file: File | FileWithMetadata, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(buffer: ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    /**
     * Uploads a list of files to the Knowledge Box. It automatically creates a new resource for each file
     * and uses the [TUS](https://tus.io/) protocol to upload the files.
     */
    batchUpload(files: FileList | File[] | FileWithMetadata[]): Observable<UploadStatus>;
    getServiceAccounts(): Observable<ServiceAccount[]>;
    createServiceAccount(data: ServiceAccountCreation): Observable<void>;
    deleteServiceAccount(saId: string): Observable<void>;
    createKey(saId: string, expires: string): Observable<{
        token: string;
    }>;
    createKeyForService(data: ServiceAccountCreation, expires: string): Observable<{
        token: string;
    }>;
    deleteKey(saId: string, saKeyId: string): Observable<void>;
    setConfiguration(config: {
        [id: string]: any;
    }): Observable<void>;
    /**
     * Update the list of users of the Knowledge Box, providing the list of users (id and role) to add and/or update, and the list of user ids to delete.
     * @param data
     */
    updateUsers(data: KbUserPayload): Observable<void>;
    /**
     * Invite a user to the Knowledge Box
     * @param data
     */
    inviteToKb(data: InviteKbData): Observable<void>;
    deleteInvite(email: string): Observable<void>;
}
