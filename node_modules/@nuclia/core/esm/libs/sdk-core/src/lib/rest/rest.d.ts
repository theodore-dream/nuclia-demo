import { Observable } from 'rxjs';
import type { INuclia, IRest } from '../models';
import { KBRoles } from '../db/kb/kb.models';
import { NucliaDBRole } from '../auth/auth.models';
export declare const ABORT_STREAMING_REASON = "Stop listening to streaming";
/**
 * Handles the elementary REST requests to the Nuclia backend, setting the appropriate HTTP headers.
 *
 * Its main methods implement the corresponding HTTP verbs (`GET` is `get()`, POST is `post()`, etc.)
 * For each of them, `extraHeaders` is an optional parameter that can be used to add headers to the request.
 *
 * On POST, PUT, PATCH and DELETE, the `synchronous` parameter will make the call synchronous,
 * meaning the response will be returned only when the operation is fully completed. It is `false` by default.
 *
 *
 * The default headers set by `Nuclia.rest` are:
 *
 * - `'content-type': 'application/json'`
 * - `Authorization` or `X-NUCLIA-SERVICEACCOUNT` depending on the type of authentication.
 *
 * The default headers will be overridden by `extraHeaders` if they have the same entries.
 *
 * `doNotParse` is a boolean that can be used to disable the automatic JSON parsing of the response. */
export declare class Rest implements IRest {
    private nuclia;
    private zones?;
    private streamErrorAt?;
    constructor(nuclia: INuclia);
    get<T>(path: string, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, zoneSlug?: string): Observable<T>;
    post<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    put<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    patch<T>(path: string, body: any, extraHeaders?: {
        [key: string]: string;
    }, doNotParse?: boolean, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    delete<T>(path: string, extraHeaders?: {
        [key: string]: string;
    }, synchronous?: boolean, zoneSlug?: string): Observable<T>;
    head(path: string, extraHeaders?: {
        [key: string]: string;
    }): Observable<Response>;
    private getHeaders;
    private fetch;
    /**
     *  Returns the full URL of the given path, using the regional or the global Nuclia backend according to the path or the provided zone slug (if any).
     */
    getFullUrl(path: string, zoneSlug?: string, insertAuthorizer?: boolean): string;
    /**
     * Check if the user has access to the given endpoint, and return the corresponding roles.
     * */
    checkAuthorization(endpoint: string): Observable<{
        allowed: boolean;
        roles: (KBRoles | NucliaDBRole)[];
    }>;
    /** Returns a dictionary giving the geographical zones available slugs by unique ids. */
    getZones(): Observable<{
        [key: string]: string;
    }>;
    getZoneSlug(zoneId: string): Observable<string>;
    /**
     * Downloads the file, converts it to a BLOB and returns its `blob:` URL.
     *
     * Use carefully with big files as it can impact the memory.
     */
    getObjectURL(path: string): Observable<string>;
    /**
     * Call an endpoint streaming its response by batch of data,
     * concatenate the data with the batch received previously until the response is marked as completed and then close the connection.
     * @param path
     * @param body body to be passed as parameter to the POST request made
     */
    getStreamedResponse(path: string, body: unknown): Observable<{
        data: Uint8Array;
        incomplete: boolean;
        headers: Headers;
    }>;
    /**
     * Call a long polling HTTP endpoint streaming its response until the connection times out.
     * This method is keeping the connection alive by calling the endpoint again when it times out until the provided controller receives an abort signal
     * (or if the endpoint returns an error unrelated to the timeout).
     *
     * @param path
     * @param controller
     */
    getStreamMessages(path: string, controller: AbortController): Observable<{
        data: Uint8Array;
        headers: Headers;
    }>;
    private fetchStream;
    private concat;
}
