import type { ExtractedDataTypes, FIELD_TYPE, FieldId, IFieldData, IResource, RelationEntityType, RelationType } from '../resource';
import type { ResourceProperties } from '../db.models';
import { RAGStrategy } from '../kb';
export type ResourceStatus = 'PENDING' | 'PROCESSED' | 'ERROR';
export type SortOrder = 'asc' | 'desc';
export declare enum SortField {
    created = "created",
    modified = "modified",
    title = "title"
}
export interface SortOption {
    field: SortField;
    limit?: number;
    order?: SortOrder;
}
export declare enum FilterOperator {
    all = "all",
    any = "any",
    none = "none",
    not_all = "not_all"
}
export type Filter = {
    [operator in FilterOperator]?: string[];
};
export interface BaseSearchOptions {
    fields?: string[];
    filters?: string[] | Filter[];
    min_score?: number;
    range_creation_start?: string;
    range_creation_end?: string;
    range_modification_start?: string;
    range_modification_end?: string;
    show?: ResourceProperties[];
    extracted?: ExtractedDataTypes[];
    field_type_filter?: FIELD_TYPE[];
    resource_filters?: string[];
    shards?: string[];
    autofilter?: boolean;
    highlight?: boolean;
}
export interface ChatOptions extends BaseSearchOptions {
    synchronous?: boolean;
    prompt?: string;
    /**
     * It will return the text blocks that have been effectively used to build each section of the answer.
     */
    citations?: boolean;
    rag_strategies?: RAGStrategy[];
    generative_model?: string;
}
export interface SearchOptions extends BaseSearchOptions {
    inTitleOnly?: boolean;
    faceted?: string[];
    sort?: SortOption;
    page_number?: number;
    page_size?: number;
    with_status?: ResourceStatus;
    with_duplicates?: boolean;
    with_synonyms?: boolean;
}
export declare enum SHORT_FIELD_TYPE {
    layout = "l",
    text = "t",
    file = "f",
    link = "u",
    datetime = "d",
    keywordset = "k",
    generic = "a",
    conversation = "c"
}
export declare namespace Search {
    enum Features {
        PARAGRAPH = "paragraph",
        DOCUMENT = "document",
        RELATIONS = "relations",
        VECTOR = "vector"
    }
    enum ResourceFeatures {
        PARAGRAPH = "paragraph",
        RELATIONS = "relations",
        VECTOR = "vector"
    }
    enum SuggestionFeatures {
        PARAGRAPH = "paragraph",
        ENTITIES = "entities",
        INTENT = "intent"
    }
    interface FindResults {
        type: 'findResults';
        resources?: {
            [id: string]: FindResource;
        };
        shards?: string[];
        next_page: boolean;
        page_number: number;
        page_size: number;
        query: string;
        total: number;
        relations?: Relations;
        autofilters?: string[];
        searchId?: string;
    }
    interface FindResource extends IResource {
        fields: {
            [id: string]: FindField;
        };
    }
    interface FindField {
        paragraphs: {
            [id: string]: FindParagraph;
        };
    }
    enum FindScoreType {
        VECTOR = "VECTOR",
        BM25 = "BM25",
        BOTH = "BOTH"
    }
    interface FindParagraph {
        order: number;
        score: number;
        score_type: FindScoreType;
        text: string;
        id: string;
        labels: string[];
        position: {
            index: number;
            start: number;
            end: number;
            start_seconds?: number[];
            end_seconds?: number[];
            page_number?: number;
        };
    }
    interface Results {
        type: 'searchResults';
        resources?: {
            [id: string]: IResource;
        };
        sentences?: Sentences;
        paragraphs?: Paragraphs;
        fulltext?: Fulltext;
        relations?: Relations;
        shards?: string[];
    }
    interface Pagination {
        total: number;
        page_number: number;
        page_size: number;
        next_page: boolean;
    }
    interface FieldResult extends IResource {
        paragraphs?: FindParagraph[];
        field?: FieldId;
        fieldData?: IFieldData;
    }
    interface Suggestions {
        type: 'suggestions';
        paragraphs?: Paragraphs;
        entities?: EntitySuggestions;
    }
    interface EntitySuggestions {
        total?: number;
        entities?: {
            value: string;
            family: string;
        }[];
    }
    interface Sentences extends Pagination {
        results: Sentence[];
        facets: FacetsResult;
    }
    interface Fulltext extends Pagination {
        results: FulltextResource[];
        facets: FacetsResult;
    }
    interface Paragraphs extends Pagination {
        results: Paragraph[];
        facets: FacetsResult;
    }
    interface Relations {
        entities: {
            [key: string]: {
                related_to: Relation[];
            };
        };
    }
    interface Relation {
        entity: string;
        entity_type: RelationEntityType;
        relation: RelationType;
        relation_label: string;
        direction: 'in' | 'out';
    }
    interface FacetsResult {
        [key: string]: {
            [value: string]: number;
        };
    }
    interface Paragraph {
        order: number;
        score: number;
        rid: string;
        field_type: SHORT_FIELD_TYPE;
        field: string;
        text: string;
        labels: string[];
        start_seconds?: number[];
        end_seconds?: number[];
        position?: {
            page_number: number;
            start: number;
            end: number;
            index: number;
        };
    }
    interface Sentence {
        score: number;
        rid: string;
        field_type: SHORT_FIELD_TYPE;
        field: string;
        text: string;
        position?: {
            page_number?: number;
            start: number;
            end: number;
            index: number;
        };
    }
    interface FulltextResource {
        score: number;
        rid: string;
        field_type: string;
        field: string;
    }
}
