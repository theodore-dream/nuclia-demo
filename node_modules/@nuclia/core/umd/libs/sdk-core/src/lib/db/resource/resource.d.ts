import { Observable } from 'rxjs';
import type { UploadResponse } from '../upload';
import { FileMetadata, UploadStatus } from '../upload';
import type { IErrorResponse, INuclia } from '../../models';
import type { Classification, CloudLink, ExtractedText, FIELD_TYPE, FileField, ICreateResource, IFieldData, IResource, KeywordSetField, LinkField, Paragraph, PositionedNER, ResourceData, ResourceField, Sentence, TextField, TokenAnnotation } from './resource.models';
import { ExtractedDataTypes, ResourceFieldProperties } from './resource.models';
import type { Search, SearchOptions } from '../search';
export interface ReadableResource extends IResource {
}
/**
 * Implements all the read operations on resources.
 *
 * A resource allows you to store content in the Knowledge Box.
 * A single resource might contain several fields.
 *
 * Fields have different types: files, links, texts, conversations, etc.
 */
export declare class ReadableResource implements IResource {
    data: ResourceData;
    private fieldTextsCache;
    /**
     * Note: Usually you will not need to create a `Resource` object yourself.
     * It is returned by the `getResource` method of the `KnowledgeBox` object. */
    constructor(data: IResource);
    getFields<T = IFieldData>(types?: (keyof ResourceData)[]): T[];
    getFieldData<T = IFieldData>(type: keyof ResourceData, fieldId: string): T | undefined;
    /** Returns the summaries generated by Nuclia for every resource fields. */
    getExtractedSummaries(): string[];
    /** Returns the texts generated by Nuclia for every resource fields. */
    getExtractedTexts(): ExtractedText[];
    /** Returns the files contained in the resource. */
    getFiles(): CloudLink[];
    /** Returns the thumbnails generated by Nuclia for every resource fields. */
    getThumbnails(): CloudLink[];
    getAnnotatedEntities(): {
        [key: string]: string[];
    };
    /** Returns the entities extracted from the resource. */
    getNamedEntities(): {
        [key: string]: string[];
    };
    getClassifications(): Classification[];
    getPositionedNamedEntities(fieldType: keyof ResourceData, fieldId: string): PositionedNER[];
    private formatTitle;
    getParagraphText(fieldType: FIELD_TYPE, fieldId: string, paragraph: Paragraph): string;
    getSentenceText(fieldType: FIELD_TYPE, fieldId: string, sentence: Sentence): string;
    private getFieldText;
}
/** Extends `ReadableResource` and implements all the write operations. */
export declare class Resource extends ReadableResource implements IResource {
    kb: string;
    uuid: string;
    private nuclia;
    get kbPath(): string;
    get path(): string;
    constructor(nuclia: INuclia, kb: string, data: IResource);
    /**
     * Modifies the resource attributes.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) => knowledgeBox.getResource('my-resource')),
          switchMap((resource) => resource.modify({ description: 'new description' })),
        )
        .subscribe(() => {
          console.log('resource modified');
        });
      ```
     */
    modify(data: Partial<ICreateResource>, synchronous?: boolean): Observable<void>;
    /** Deletes the resource. */
    delete(synchronous?: boolean): Observable<void>;
    /** Triggers a resource reprocessing. */
    reprocess(): Observable<void>;
    getField(type: FIELD_TYPE, field: string, show?: ResourceFieldProperties[], extracted?: ExtractedDataTypes[]): Observable<ResourceField>;
    /** Returns the thumbnails generated by Nuclia for every resource fields as `blob:` URLs. */
    getThumbnailsUrl(): Observable<string[]>;
    /** Deletes the field with the given type and id. */
    deleteField(type: FIELD_TYPE, field: string, synchronous?: boolean): Observable<void>;
    /**
     * Adds or updates a field in the resource.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) =>
            knowledgeBox.getResource('my-resource').pipe(
              switchMap((resource) =>
                resource.setField(FIELD_TYPE.text, 'my-field', {
                  body: '*my text*',
                  format: 'MARKDOWN',
                }),
              ),
            ),
          ),
        )
        .subscribe(() => {
          console.log('field added');
        });
      ```
    */
    setField(type: FIELD_TYPE, field: string, data: TextField | LinkField | FileField | KeywordSetField): Observable<void>;
    /**
     * Uploads a file in the resource. The field will be stored in the indicated field.
     *
     * Example:
      ```ts
      nuclia.db
        .getKnowledgeBox('my-account', 'my-kb')
        .pipe(
          switchMap((knowledgeBox) => knowledgeBox.getResource('my-resource')),
          switchMap((resource) => resource.upload(fileInputElement.files[0])),
        )
        .subscribe(() => {
          console.log('file uploaded');
        });
      ```
    */
    upload(field: string, file: File, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    upload(field: string, buffer: ArrayBuffer, TUS?: boolean, metadata?: FileMetadata): Observable<UploadResponse>;
    /**
     * Uploads a list of files in the resource. It automatically creates a new field for each file (named according to the filename).
     * It uses the [TUS](https://tus.io/) protocol to upload the files. */
    batchUpload(files: FileList | File[]): Observable<UploadStatus>;
    /** Performs a search operation in the resource (similar as `find()` but results are not nested). */
    search(query: string, features?: Search.ResourceFeatures[], options?: SearchOptions): Observable<Search.Results | IErrorResponse>;
    /** Performs a find operation in the resource. */
    find(query: string, features?: Search.ResourceFeatures[], options?: SearchOptions): Observable<Search.FindResults | IErrorResponse>;
    setLabels(fieldId: string, fieldType: string, paragraphId: string, labels: Classification[]): Observable<void>;
    setEntities(fieldId: string, fieldType: string, entities: TokenAnnotation[]): Observable<void>;
}
